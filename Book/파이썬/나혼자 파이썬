출처: 이창현(2020), "나혼자 파이썬", 디지털북스
해당 책을 학습하고 개인 학습용으로 정리한 내용입니다.

* 파이썬 문법 리마인딩을 위한 복습!! *

** 파이썬의 특징
- 파이썬은 대화형의 인터프리터 언어
- 플랫폼 독립적 언어. 여러 대표적인 운영체제에서 플랫폼 독립적으로 동작함.(컴파일하지 않고 바로 해석하는 인터프리터 방식으로 동작하기 때문에 사용하기 쉬움)
- 간단하고 쉬운 문법


** 변수와 데이터 타입
변수를 사용하는 이유 => 프로그래머가 직접 메모리 번지를 일일히 다 기억하여 점근하지 않고, 변수를 통해 메모리 관리 및 데이터 입출력을 용이하게 해주기 때문.

* 변수의 이름은 알파벳, 숫자, 언더바로 구성. 특수문자 불가! 변수 이름의 첫 글자는 숫자로 불가! 중간에 공백 포함 불가!
* 변수 이름은 대소문자를 구분하므로 대소문자가 다르면 다른 변수로 간주.

* 파이썬의 기본 데이터 타입: 정수, 실수, 문자열. type(변수) 함수를 통해 데이터 타입을 알아낼 수 있음.
* 파이썬에서는 문자(Character) 타입이 별도로 존재하지 않고, 문자열에서 1개의 문자만 표현하면 그것을 문자로 인식.

ord(문자): 문자에 해당하는 아스키 코드를 반환
chr(아스키코드): 아스키 코드에 맵핑된 문자를 반환


** 입력
변수 = input(사용자가 입력받을 때 안내를 도와주는 문자열)
input() 함수를 통해 입력받은 값의 타입은 문자열
목적에 맞게 사용하기 위해서는 입력 받은 값의 타입을 변환해서 사용해야함.(타입 캐스팅)


** 타입 캐스팅
int(데이터): 어떤 타입의 데이터를 정수로 변경.
str(데이터): 어떤 타입의 데이터를 문자열로 변경.
float(데이터: 어떤 타입의 데이터를 실수로 변경.
ord(문자): 문자를 아스키 코드로 변경.
chr(아스키코드): 아스키코드를 문자로 변경.


** 주석
한 라인 주석을 처리할 때는 #을 주석 처리할 라인 앞에 사용.
여러 라인 주석을 처리할 때는 """ 또는 '''을 주석 처리할 여러 라인들 앞뒤에 사용.


** 연산자
'/' 연산자는 나누기 연산자로 소수점까지 표현, '//' 연산자도 나누기 연산자이지만 소수점을 없앰.
'**' 지수 연산자와 '//' 나누기 연산자도 대입연산자 '**=', '//=' 지원함.
논리 연산자 'not', 'and', 'or'을 지원함. ex) not(a < 10), a and b , a or b
또한 이를 이용한 삼항 연산자 'condition and a or b'를 지원함.

Tip, 한 라인에 코드가 길어질 경우 임의로 개행을 하면 문법 오류가 발생함. 그래서 개행 시에 문장 끝에 '₩'를 붙여주면 다음 문장과 이어진다는 표시이기 때문에 문법 오류가 발생하지 않음.


** 비트 연산자
~ : 비트를 반전시킴. 비트 연산자 중 유일한 단항 연산자. 비트 부정 연산을 한 후에 1을 더하면 그 값의 더하면 그 값의 음수를 얻을 수 있음.(~a+1) (NOT)
^ : 두 개의 비트가 달라야 1이 됨. (XOR)
& : 대응되는 비트가 모두 1일 때 1이 됨. (AND)
| : 대응되는 비트가 모두 0일 때 0이 됨. (OR)
<< : 지정한 수만큼 왼쪽으로 비트를 이동시킴.
>> : 지정한 수만큼 오른쪽으로 비트를 이동시킴.


** 조건문
if ~ elif ~ else
if 조건문에서 아무것도 처리하고 싶지 않을 때 pass 사용.


** 반복문
파이썬에서는 while문보다 for문의 사용 빈도가 높음. for문은 리스트,튜플,딕셔너리와 같은 타입과 연계해서 사용 가능하기 때문.

for 변수 in range(시작값, 끝값, 증가값):
    반복할 문장

range() 함수는 전달 인자값에 따라 숫자 리스트를 자동으로 만들어줌. 이때 끝값은 리스트에 포함되지 않음.


** 함수
내장 함수는 파이썬 언어에서 사용자에게 제공하는 함수로 외부 모듈과 달리 별도의 import나 설정 없이 사용 가능.

* 주요 내장 함수:
abs(x): 절대값 반환 함수
divmod(a,b): a를 b로 나눈 몫과 나머지를 튜플 형태로 돌려주는 기능
eval(expression): 실행 가능한 문자열을 입력 받아 문자열열을 실행한 결과값을 돌려주는 기능
id(object): 객체를 입력 받아 객체의 고유 주소 값을 돌려주는 기능
len(s): 입력한 s의 길이 또는 요소 전체의 개수를 돌려주는 기능
list(f, iterable): 함수 f와 반복 가능한 iterable 자료형을 받아서 입력받은 각 요소를 함수 f가 수행한 결과를 묶어서 돌려주는 기능
max(iterable): 인수로 반복 가능한 자료형을 입력 받아 그 최대값을 돌려주는 기능
min(iterable): 인수로 반복 가능한 자료형을 입력 받아 그 최소값을 돌려주는 기능
open(filename): 인수로 파일 이름을 입력 받아 파일 객체를 돌려주는 기능

* 사용자 정의 함수
def 함수이름(전달인자):
    함수 내용

return문은 함수 정의 시 반드시 필수는 아님. 결과값을 반환할 필요가 있을 경우에만 return 문 사용.

함수 안의 변수들과 함수의 매개변수는 지역 변수이므로 함수가 수행될 때 자동으로 메모리에 할당되었다가 함수가 띁나면 자동을 메모리에서 소멸됨.
함수 안에서 전역변수를 선언하기 위해서는, 함수 안의 변수명 앞에 global 키워드를 붙여 선언하면 됨. (global 키워드와 함께 값 할당하면 에러 발생! global 선언할 때는 global 선언만 해야 함!)


** 다양한 데이터 형태
1. 리스트
* 리스트 생성:
리스트 이름 = [값1, 값2, 값3, ...]

* 리스트 추가:
리스트 이름.append(값)

* 리스트 초기화:
리스트 이름 = []

* 리스트 접근 범위 지정:
리스트 이름[시작인덱스:끝인덱스+1]    //시작 인덱스나 리스트 인덱스를 생략할 경우, 나머지 전체를 나타냄. 리스트이름[:]은 전체 리스트를 나타냄.

* 리스트간의 연산:
리스트간의 더하기 연산과 곱하기 연산 가능. 더할 경우, 하나의 리스트로 합쳐딤. 곱할 경우, 리스트 항목들이 곱한 수만큼 반복해서 늘어남.

* 리스트 수정:
리스트의 인덱스에 접근하여 수정 가능.
ktx[2:3] = [300, 301, 302]  =>  [10, 20, 300, 301, 302, 40]
ktx[2] = [300, 301, 302]  =>  [10, 20, [300, 301, 302], 40]     //주의.리스트의 인덱스 값에 리스트가 들어감

* 리스트 삭제:
del(리스트 이름[위치])     //리스트의 항목을 삭제
리스트 이름[시작인덱스:끝인덱스+1]=[] //리스트의 여러 항목을 한 번에 삭제

* 리스트의 유용한 함수들
리스트 이름.append(값) : 리스트의 가장 끝에 항목을 추가
리스트 이름.pop() : 리스트의 가장 끝의 항목을 삭제
리스트 이름.reverse() : 리스트의 항목을 역순으로 변경
리스트 이름.sort() : 리스트의 항목을 오름차순으로 정렬
리스트 이름.remove(값) : 리스트에서 지정한 값을 삭제(동일한 값이 여러 개 았다면 첫번째 값만 삭제)
리스트 이름.insert(인덱스, 값) : 리스트에서 지정한 위치에 값을 삽입
리스트 이름.extend(리스트) : 리스트와 리스트를 더하는 기능. 리스트1+리스트2 리스트 더하기 연산과 동일!
리스트 이름.count(값) : 리스트에서 찾을 값의 개수를 셈
len(리스트 이름) : 리스트으 전체 항목 개수를 셈
del(리스트 이름[인덱스]) : 리스트에서 해당 항목을 삭제
리스트 이름.index(값) : 리스트에서 지정한 값을 찾아 위치를 반환
리스트2 = sorted(리스트1) : 리스트1의 본체는 변형하지 않고 정렬된 리스트를 반환

2. 튜플
튜플은 리스트와 비슷하게 목록의 형태로 값을 저장. 그러나 리스트와는 다르게 값을 수정할 수 없고 읽기만 가능.

* 튜플 생성:
튜플 이름 = (값1, 값2, 값3, ...)
한개의 튜플을 만들 때에는 한 개의 항목 뒤에 콤마를 붙여서 생성(인터프리터에게 튜플임을 알려줘야 함.) ex) tp1 = 1,

* 튜플 연산:
튜플은 값을 변경하려고 하면 오류가 발생함. 단지, 튜플의 항목에 접근하여 출력하거나 항목끼리의 연산 정도만 가능.
튜플 이름[인덱스] : 튜플의 하나의 항목에 접근
튜플 이름[시작인덱스:끝인덱스+1] : 튜플의 범위에 접근

* 튜플, 리스트 간의 변환
list(데이터): 리스트로 변환
tuple(데이터): 튜플로 변환

3. 딕셔너리(다른 프로그래밍 언어에서 제공하는 map과 비슷)
* 딕셔너리 생성:
딕셔너리 변수 = {키1: 값1, 키2: 값2, 키3: 값3 ...}

* 딕셔너리의 항목 추가:
딕셔너리 이름[키]=값

* 딕셔너리의 항목 삭제:
del(딕셔너리 이름[키])

* 딕셔너리의 사용
딕셔너리 이름.get(키) : 키를 통해 값에 접
딕셔너리 이름.keys() : 딕셔너리의 키만 반환        //반환 값에 dict_keys가 붙어 나옴. 이를 없애고 싶으면 list() 함수를 사용하면 됨.
딕셔너리 이름.values() : 딕셔너리의 values만 반환 //반환 값에 dict_values가 붙어 나옴. 이를 없애고 싶으면 list() 함수를 사용하면 됨.
키 in 딕셔너리이름 : 딕셔너리 항목 중에 해당 키가 있는지 확인


** 문자열 연산
* 문자열 더하기, 곱하기
문자열 더하기 => 문자열이 결합됨
문자열 곱하기 => 문자열 n번 반복하여 결합됨

* 문자열 접근
문자열 이름[인덱스] : 인덱스 위치에 해당하는 문자에 접근

* 문자열 자르기
문자열[시작인덱스:끝인덱스+1] : 문자열 인덱스를 통해 자르기

* format 함수를 사용한 포매팅
ex) print('현재 시간은 {0}시 {1}분 입니다.' .format(value1, value2))

**  다양한 문자열 함수
* 문자열 개수 찾기
개수 = 문자열.count('검색할 문자 또는 문자열') : 문자(문자열) 개수 리턴

* 문자열 위치 찾기
위치 = 문자열.find('검색할 문자 또는 문자열') : 문자열 위치 리턴, 찾는 값이 없을 경우 -1 리턴
위치 = 문자열.index('검색할 문자 또는 문자열') : 문자열 위치 리턴, 찾는 값이 없을 경우 오류 리턴

* 문자열 삽입 및 분리
새로운 문자열 = 구분자.join(문자열)     //str=','.join('abcd')  =>  'a,b,c,d'
리스트 = 문자열.split(구분자)

* 문자열 대/소문자 변환
변경된 문자열 = 문자열.upper()
변경된 문자열 = 문자열.lower()

* 문자열 공백 없애기
변경된 문자열 = 문자열.lstrip() : 문자열의 왼쪽 공백 제거
변경된 문자열 = 문자열.rstrip() : 문자열의 오른쪽 공백 제거
변경된 문자열 = 문자열.strip() : 문자열의 양쪽 공백 제가

* 문자열 구성 파악
문자열.isdigit() : 문자열이 숫자로만 구성되어 있는지 검사
문자열.isapha() : 문자열이 글자로만 구성되어 있는지 검사
문자열.isupper() : 문자열이 대문자로만 구성되어 있는지 검사
문자열.islower() : 문자열이 소문자로만 구성되어 있는지 검사
문자열.isspace() : 문자열이 공백으로만 구성되어 있는지 검사


** 클래스
* 클래스의 선언
class 클래스 이름:
    # 멤버 변수 선언
    # 메소드 정의

클래스 안의 메소드는 첫번째 매개변수로 self를 지정함. (self는 클래스 자기자신의 객체를 나타내는 의미)

* 객체 생성하기
ex) mycar = Car()

* 클래스의 생성자
class 클래스이름:
    def__init__(self):
        # 생성자 코드


** 상속성
* 부모 클래스 상속
class 자식클래스이름(부모클래스이름):
    # 이 부분에 자식 클래스의 코드 입력























