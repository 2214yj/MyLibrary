
* <나혼자 파이썬>, <Do it! 점프 투 파이썬> 책과 안겹치는 내용 위주로 *

<실수형>
실수형의 소수부가 0이거나 정수부가 0인 소수는 0을 생략하고 작성 가능 ex) a = 5.  b = -.7
e나 E를 이용한 지수 표현 방식을 이용함. 1e9는 10의 9제곱이므로 큰 수를 표현할 때 직접 숫자를 입력하기 보다는 지수 표현 방식을 이용하는 것이 편함.
컴퓨터는 실수를 정확히 표현하지 못함. 따라서 이로 인해 원하는 결과를 도출하기 어려울 수 있음.
    이럴 때 round(실수형 데이터, 반올림하고자 하는 위치 -1) 함수를 사용하면 됨.
    흔히 코딩 테스트 문제에서는 실수형 데이터를 비교할 때 소수점 다섯 버째 자리에서 반올림한 결과가 같으면 정답으로 인정하는 식으로 처리함.

<리스트형>
** 리스트 컴프리헨션을 이용하면 [] 안에 조건문과 반복문을 넣는 방식으로 리스트를 초기화할 수 있음.
    N*M 크기의 2차원 리스트를 초기화하는 코드:
            array = [[0] * m for _ in range(n)]
    Q. N*M 크기의 2차원 리스트를 다음과 같이 초기화하면 안될까?
            array = [[0] * m]  * n
            이렇게 2차원 리스트를 초기화할 경우, 내부적으로 포함된 n개의 리스트가 모두 동일한 객체에 대한 n개의 레퍼런스로 인식되기 때문에
            배열 중 하나의 값만 바꿔도 n개가 함께 바뀜. 따라서, 특정한 크기를 가지는 2차원 배열을 사용할 때에는 리스트 컴프리헨션을 이용해야 함.

* 언더바(_)는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 언더바를 자주 사용함.

** 리스트 관련 메서드의 시간 복잡도
변수명.append()        //O(1)
변수명.sort([reverse=True])      //O(NlogN)
변수명.reverse()       //O(N)
변수명.insert(삽입할 위치 인덱스, 삽입할 값)   //O(N)
변수명.count(특정값)      //O(N)
변수명.remove(특정값)     //O(N)

=> 되도록 insert() 보다 append()를 사용하는 것이 효율적!

리스트에서 여러개의 원소를 한꺼번에 제거하는 방법:
    remove_set = {3,5}
    result = [i for i in 리스트 if i not in remove_set]

<튜플 자료형>
튜플 자료형은 그래프 알고리즘을 구현할 때 자주 사용됨. 최단 경로를 찾아주는 알고리즘의 내부에서는 우선순위 큐를 이용하는데
해당 알고리즘에서 우선순위 큐에 한 번 들어간 값은 변경되지 않음 => 튜플 사용.
튜플은 리스트에 비해 상대적으로 공간 효율적!

<사전 자료형>
파이썬의 사전 자료형은 내부적으로 해시 테이블을 이용하므로 기본적으로 데이터의 검색 및 수정에 있어서 O(1)의 시간에 처리 가능.

<집합 자료형>
사전 자료형과 집합 자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없다는 특징이 있음.
집합은 중복을 허용하지 않으며 순서가 없음.
집합은 리스트, 문자열을 이용해서 초기화 가능. (이때 set() 함수 사용)
특정 원소가 존재하는지를 검사하는 연산의 시간 복잡도는 사전 자료형과 마찬가지로 O(1)이다. (데이터 조회 및 수정에 있어서 O(1)의 시간에 처리 가능.
집합 자료형의 add(), remove() 함수는 모두 시간 복잡도가 O(1)이다.

** 파이썬에서는 여러 개의 데이터를 담는 자료형(리스트, 튜플, 문자열, 사전과 같은 자료형)에게 'in 연산자'와 'not in 연산자'를 제공.

** 사전 자료형과 집합 자료형의 특징
리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있음.
사전 자료형과 집합 자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없음.
사전의 키 혹은 집합의 원소를 이용해 O(1)의 시간 복잡도로 조회.

<조건문>
조건부 표현식을 사용하면 if ~ else문을 한 줄에 작성할 수 있음. 그러나 가독성이 떨어짐.
    ex) a = '짝수' if number % 2 == 0 else '홀수'

* 파이썬에서는 0 < x < 20과 같이 사용 가능.

<함수>
코딩 테스트에서 테스트 케이스만큼 특정한 알고리즘을 수행한 결과를 반복적으로 출력하도록 요구하는 문제일 경우, 함수를 사용하면 매우 효과적으로 풀 수 있음.
파이썬 함수는 여러개의 반환값들을 가질 수 있음.

* 람다 함수를 사용할 경우, 곧바로 인자를 전달해서 사용 가능!
    ex) print((lambda a,b: a + b)(2,7))

* 람다 표현식 예시1: 내장 함수에서 자주 사용되는 람다 함수
    ex) print(sorted(array, key = lambda x: [1])    //sorted 내장 함수는 key로 함수를 설정해서 정렬 가능.

* 람다 표현식 예시2: 여러 개의 리스트에 적용
    ex) result = map(lambda a,b: a+b, list1, list2)


<입출력>
** 여러개의 숫자를 공백으로 구분하여 입력 받기 (입력 받은 문자열을 띄어쓰기로 구분하여 각각 정수 자료형의 데이터로 저장해야 함)
    map(int, input().split()))      //공백으로 구분된 데이터의 개수가 많지 않은 경우
    list(map(int, input().split())) //데이터 개수가 많은 경우

** 입력 개수가 많은 경우 기본 input() 함수를 사용하면 동작 속도가 느려서 시간 초과로 오답 판정을 받을 수 있음
=> sys.stdin.readline() 함수를 이용하자!
** sys 라이브러리를 사용할 때는 한 줄 입력을 받고 나서 rstrip() 함수를 꼭 호출해야 함. readline()으로 입력하면 입력 후 엔터가 줄 바꿈 기호로 입력되는데, 이 공백 문자를 제거하기 위해 rstrip() 함수가 필요!
    ex) input = sys.stdin.readline().rstrip()

<주요 라이브러리의 문법과 유의점>
표준 라이브러리: 특정한 프로그래밍 언어에서 자주 사용되는 표준 소스코드를 미리 구현해 놓은 라이브러리.
파이썬에서 지원하는 표준 라이브러리는 굉장히 다양하지만, 코딩 테스트를 준비하며 반드시 알아야 하는 라이브러리는 6가지 정도.
    - 내장 함수: print(), input()과 같은 기본 입출력 기능부터 sorted()와 같은 정렬 기능을 포함하고 있는 기본 내장 라이브러리. 필수적인 기능을 포함.
    - itertools: 파이썬에서 반복되는 형태의 데이터를 처리하는 기능을 제공하는 라이브러리. 순열과 조합 라이브러리를 제공.
    - heapq: 힙(HEAP) 기능을 제공하는 라이브러리. 우선순위 큐 기능을 구현하기 위해 사용.
    - biselect: 이진 탐색(Binary Search) 기능을 제공하는 라이브러리.
    - collections: 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함하고 있는 라이브러리.
    - math: 필수적인 수학적 기능을 제공하는 라이브러리. 팩토리얼, 제곱근, 최대공약수, 삼각함수 관련 함수부터 파이(pi)와 같은 상수를 포함하고 있음.

1. 내장 함수
sum() 함수는 iterable 객체(반복 가능한 객체! 리스트, 사전 자료형, 튜플 자료형 등)가 입력으로 주어졌을 때, 모든 원소의 합을 반환.
sorted() 함수는 iterable 객체가 들어왔을 때, 정렬된 결과를 반환. key 속성으로 정렬 기준을 명시할 수 있고 reverse 속성으로 정렬된 결과 리스트를 뒤집을지 여부를 거렁할 수 있음.
    ex) result = sorted([9,1,8,5,4], reverse = True)    //내림차순으로 정렬
        result = sorted([('홍길동', 35), ('이순신', 75), ('이무개', 50)], key = lamda x: x[1], reverse = True)
            //정렬 기준은 key 속성을 이용해 명시할 수 있음. 원소를 튜플의 두번째 원소를 기준으로 내림차순으로 정렬한 예시.

2. itertools
itertools는 파이썬에서 반복되는 데이터를 처리하는 기능을 표함하고 있는 라이브러리.
매우 다양한 클래스들을 제공하지만 코딩 테스트에서 가장 유용하게 사용할 수 있는 클래스는 permutations, combinations
permutations는 iterable 객체에서 r개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)를 계산해줌.
    ex) 리스트 ['A', 'B', 'C']에서 3개(r=3)를 뽑아 나열하는 모든 경우를 출력하는 예시
    from itertools import permutations
    data = ['A', 'B', 'C']
    result = list(permutations(data, 3))    # 모든 순열 구하기

combinations는 iterable 객체에서 r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우(조합)를 계산.
    ex) 리스트 ['A', 'B', 'C']에서 2개(r=2)를 뽑아 순서에 상관없이 나열하는 모든 경우를 출력하는 예시
    from itertools import combinations
    data = ['A', 'B', 'C']
    result = list(combinations(data,2))     # 2개를 뽑는 모든 조합 구하기

product는 permutations와 같이 iterable 객체에서 r개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)을 계산. 다만, 원소를 중복하여 뽑음. 뽑고자 하는 데이터의 수를 repeat 속성값으로 넣어줌.
    ex) 리스트 ['A', 'B', 'C']에서 중복을 포함하여 2개(r=2)를 뽑아 나열하는 모든 경우를 출력하는 예시
    from itertools import product
    data = ['A', 'B', 'C']
    result = list(product(data, repeat=2))  # 2개를 뽑는 순열 구하기(중복 허용 => (B,B) 허용)

combinations_with_replacement는 combinations와 같이 iterable 객체에서 r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모둔 경우(조합)를 계산. 다만 원소를 중복해서 뽑음.
    ex) 리스트 ['A', 'B', 'C']에서 주옥을 포함하여 2개(r=2)를 뽑아 순서에 상관없이 나열하는 모든 경우를 출력하는 예시
    from itertools import combinations_with_replacement
    data = ['A', 'B', 'C']
    result = list(combinations_with_replacement(data, 2))   # 2개를 뽑는 모든 조합 구하기(중복 허용)

3. heapq
힙(Heap) 기능을 위한 heapq 라이브러리. heapq는 다익스트라 최단 경로 알고리즘을 포함해 다양한 알고리즘에서 우선순위 큐 기능을 구현하고자 할 때 사용.
heapq 외에도 PriorityQueue 라이브러리를 사용할 수 있지만 코딩 테스트 환경에서는 보통 heapq가 더 빠르게 동작함.
파이썬의 힙은 최소 힙(Min Heap)으로 구성되어 있으므로 단순히 원소를 힙에 전부 넣었다가 빼는 것만으로도 시간 복잡도 O(NlogN)에 오름차순 정렬이 완료됨.
heapq.heappush() : 힙에 원소를 삽입
heapq.heappop() : 힙에서 원소를 꺼냄

내용이 어려우므로 일단 생략... 힙 정렬 공부할 때 다시 읽기 (454p)

4. bisect
이진 탐색을 쉽게 구현할 수 있도록 bisect 라이브러리를 제공.
bisect 라이브러리는 '정렬된 배열'에서 특정한 원소를 찾아야 할 때 마우 효과적으로 사용됨.
bisect_left(a,x) : 정렬된 순서를 유지하면서 리스트 a에 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드.
bisect_right(a,x) : 정렬된 순서를 유지하도록 리스트 a에 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메서드.
    ex) 1  2  [bisect_left(a,4)가 가리키는 인덱스(=2)]  4  4  [bisect_right(a,4)가 가리키는 인덱스(=4)]  8

또한 bisect_left() 함수와 bisect_right() 함수는 '정렬된 리스트' '값이 특정 범위에 속하는 원소의 개수'를 구하고자 할 때, 효과적으로 사용 가능.
     ex) 특정 범위에 해당하는 원소의 개수를 구하는 count_by_range() 함수
        def count_by_range(a, left_value, right_value):
            right_index = bisect_right(a, right_value)
            left_index = bisect_left(a, left_value)
            return right_index - left_index

5. collections
자료구조를 제공하는 표준 라이브러리.
코딩 테스트에서 유용하게 사용되는 클래스는 deque와 Counter.

보통 파이썬에서는 deque를 사용해 큐를 구현. 별도로 제공되는 Queue 라이브러리가 있지만 일반적인 큐 자료구조를 구현하는 라이브럴리는 아님. 따라서 deque를 이용해 큐를 구현해야 함.
deque가 리스트에 비해 시간 복잡도가 낮음.
deque의 시간 복잡도는 모두 O(1)
deque에서는 리스트 자료형과 다르게 인덱싱, 슬라이싱 등의 기능은 사용할 수 없지만 연속적으로 나열된 데이터의 시갖 부분이나 끝 부분에 데이터를 삽입/삭제할 때는 매우 효과적으로 사용 가능.
deque는 스택이나 큐의 기능을 모두 포함하므로 스택 혹은 큐 자료구조의 대용으로 사용될 수 있음.
popleft() : 첫 번째 원소 제거
pop() : 마지막 원소 제거
appendleft(x) : 첫 번쨰 인덱스에 원소 삽입
append(x) : 마지막 인덱스에 원소 삽입
=> 큐 자료구조로 이용할 경우, 원소 삽입 => append() / 원소 삭제 => popleft()

Counter는 등장 횟수를 세는 기능을 제공. iterable 객체가 주어졌을 때, 해당 객체 내부의 원소가 몇 번씩 등장했는지를 알려줌.
    ex)
        from collections import Counter
        counter = Counter(['red', 'blue', 'red', 'green', 'blue', 'blue'])
        print(counter['blue'])  # 'blue'가 등장한 횟수 출력
        print(dict(counter)     # 사전 자료형으로 변환. {'red': 2, 'blue': 3, 'green': 1}

6. math
자주 사용되는 수학적인 기능을 포함하고 있는 라이브러리. 팩토리얼, 제곱근, 최대 공약수 등을 계산해주는 기능을 포함하고 있음.
math.factorial(x) : x! 팩토리얼
math.sqrt(x) : x의 제곱근
math.gcd(a, b) : a와 b의 최대 공약수를 반환.
또한 수학 공식에서 자주 등장하는 pi, e 등의 상수를 제공.

















