5장 함수
## 힘수
# 익명함수, 익명함수를 더 많이 씀.
const f = function() {}

# 선언적 함수
function f () {}

# API
=> Application Programming Interface
애플리케이션 프로그램을 만들 때의 약속

# 나머지 매개변수(가변 매개변수)
function(...매개변수) {}
=> 나머지 매개변수는 매개변수 중 맨 마지막에 위치해야 하며 자료형이 배열(매개변수들이 배열로 들어옴).

# 전개 연산자
함수(...배열)
=> 배열 앞에다 ...을 써서 함수를 호출할 수 있게 해주는 특별한 문법. 배열을 전개해서 실행할 수 있게 해줌.

## 구 버전 자바스크립트
# 구 버전 가변 매개 변수
배열 내부에서 사용할 수 있는 특수한 변수인 arguments를 활용. arguments는 매개변수와 관련된 여러 정보를 확인할 수 있고 배열과 비슷하게 사용 가능.

# 구 버전 전개연산자 구현하기
전개 연산자는 최신 버전의 자바스크립트에 추가된 기능. 구 버전의 자바스크립트에서는 apply() 함수를 사용한 굉장히 특이한 채턴의 코드를 사용함.

# 구 버전 기본 매개변수 구현하기
짧은 조건문을 사용하여 기본 매개변수 구현 가능.


## 클래스의 고급 기능
자원의 부족으로 인해 성능을 무조건적으로 중시했던 과거와 달리, 현재는 가독성이 중요.
점점 저렴해지는 컴퓨터 가격과 점점 비싸지는 개발자의 몸값, 최대한 저렴한 개발자를 고용해도 코드를 읽고 이해하는데 문제 없게 해야 함.
프로그램의 규모가 커지고 복잡해짐. 현대에는 성능보다는 가독성과 안전성을 중시.
ex) 매개변수의 기본값 설정 가능 => 안전성 증가

## 콜백 함수
자바스크립트는 함수도 하나의 자료형이므로 매개변수로 전달 가능. 이렇게 매개변수로 전달하는 함수를 콜백함수라고 함.

## 콜백 함수를 활용하는 함수
# forEach()
배열이 갖고 있는 함수(메소드)로써 단순하게 배열 내부의 요소를 사용해서 콜백 함수를 호출. for 반복문과 달리, break 사용 불가.
ex)
배열.forEach(function (value, index) {
    console.log(`${index}번째의 값은 ${value}`)
}

# map
배열이 갖고 있는 함수(메소드)로써 콜백 함수에서 리턴한 값들을 기반으로 새로운 배열을 만드는 함수.
ex)
배열.map( function (value, index, array) {
    return value * value
})

# filter
배열이 갖고 있는 함수(메소드)로써 콜백 함수에서 리턴하는 값이 true인 것들만 모아서 새로운 배열을 만드는 함수.
배열.filter( function(value, index, array) {
    return value % 2 === 0
}

## 화살표 함수
화살표 함수는 function 키워드 대신 화살표(=>)를 사용. function 키워드를 사용하여 생성하는 함수와 미묘한 차이를 가짐. (6장에서 배울 예정)
(매개변수) => { }
만약 함수 내의 문장이 리턴문 뿐이라면 다음과 같이 return 키워드 생략 가능.
(매개변수) => 리턴값

# forEach, map, filter 함수를 연속적으로 사용 가능.
이렇게 어떤 메소드가 리턴하는 값을 기반으로 해서 함수를 줄줄이 사용하는 것은 '메소드 체이닝'이라고 부름
ex)
numbers
    .filter((value) => value % 2 === 0)
    .map((value) => value * value)
    .forEach((value) => {
        console.log(value)
    })

## 타이머 함수
const a = setTimeout( handler, 밀리초(1000=1초) )    //특정한 시간 후에 한 번 => 고급 단계에서 특별한 사용법을 가짐
const b = setInterval( handler, 밀리초(1000=1초) )   //특정한 시간마다 호출

일반적으로 현대에는 콜백 함수는 함수의 마지막 매개 변수에 오는 것이 일반적, 그러나 setTimeout과 setInterval은 오래 전에 만들어졌기 때문에
콜백 함수가 앞에 온다.

## 타이머 제거 함수
clearTimeout(a)
clearInterval(b)

## 즉시 호출 함수
함수를 만들고 즉시 호출하는 함수 IIFE(Immediately Invoked Function Expression)라고 부르기도 함.
(function () {
})()
또는
(() => {
})()
와 같이 사용함.
중복으로 인한 충돌을 피하기 위해 사용됨. 즉시 호출 함수 내부에서 선언되는 상수와 변수 함수 내부에서만 작동하기 때문에 충돌이 발생하지 않음.
현대 자바스크립트에서는 이렇게 사용할 필요가 없지만 레거시 코드를 이해하기 위해서 필요.

즉시 호출 함수를 사용하지 않더라도 충돌 문제를 해결하기 위해 중괄호{}를 사용해서 생성한 블록과 함수 블록을 사용 가능.
블록 내부에서 블록 외부의 변수와 같은 이름의 변수를 선언하더라도 충돌하지 않고 외부 변수를 가림. 내부 블록에서는 선언한 변수만 볼 수 있음.
이렇게 블록이 다른 경우, 내부 변수가 외부 변수를 가리는 현상을 섀도잉이라고 부름.
단, 구 버전 자바스크립트의 var 키워드는 함수 블록을 사용하는 경우에만 변수 충돌을 막을 수 있음. (테스트 결과, 외부에서 var b = 400; 선언 후 블록 내부에서 { var b = 500;} 선언할 경우, 외부 변수 b의 값이 500으로 변경됨.)
지금도 구 버전의 자바스크립트를 지원하는 웹 브라우저(인터넷 익스플로러)에 대응해야 하는 경우가 많고, Babel 등 최신 버전의 자바스크립트를 구 버전의 자바스크립트로 변경해주는 트랜스 파일러도 단순한 블록으로 함수 충돌을 막는 코드는 제대로 변환해주지 못함.
그래서 많은 개발자들이 함수 블록을 사용해 이런 문제를 해결. 결론, 충돌 문제를 해결하기 위해 사용하는 것이면 즉시 호출 함수가 유용!

## 엄격 모드
블록의 가장 위쪽에 'use strict'를 선언하여 사용.
자바스크립트 언어는 무척이 유연한 언어이기 때문에 문법이 맞지 않아도 잘 돌아가는 경우가 많음.
이런 경우, 내부적으로 큰 위험성을 내포하고 있으므로 이를 방지하기 위해 엄격하게 검사를 해주는 엄격 모드가 등장. 자바스크립트는 'use strict' 문자열을 읽어들인 순간부터 코드를 엄격하게 검사함.
그러나 전체 공동으로 작성하는 소스코드에 대해 엄격 모드를 설정하면 이에 따른 문제 발생 가능 => 즉시 호출 함수 내부에서 맨 윗줄에 엄격 모드를 선언해서 사용. 즉시 호출 함수 내부에서만 엄격 모드가 동작.

## 선언적 함수와 익명 함수의 차이
자바스크립트는 네임스페이스라는 문법이 따로 없어서 이름 충돌이 쉽게 발생할 수 있는 언어. 그래서 이후에 활용하는 객체로 네임스페이스를 유사적으로 만들어 활용. 따라서 선언적 함수를 잘 안씀.
익명 함수의 경우, 그냥 변수 생성과 같기 때문에 코드가 위에서 아래로 읽어지면서 차례대로 함수가 생성됨.
반면에, 선언적 함수는 전체 코드를 읽기 전에 선언한 순서대로 만들어짐. => 함수를 선언하기 전에 함수를 먼저 호출해도 문제없이 실행됨.
이에 따라, 익명 함수와 선언적 함수를 동시에 실행할 때 문제가 발생할 수 있음.

ex)
함수()
함수 = function() { console.log('익명 함수입니다.') }
function 함수() { console.log('선언적 함수입니다.') }
함수()
=> 실행 결과, '선언적 함수입니다' 출력 후, '익명 함수입니다.' 출력.
(선언적 함수가 미리 만들어지므로 첫번째에서는 선언적 함수가 호출이되고 아래쪽 호출에서는 익명 함수가 함수라는 변수를 뒤집어 쓰기 때문에 익명 함수가 호출됨.)
결론, 선언적 함수는 전체 코드를 실행하기 전에 만들어지고 익명 함수는 코드를 하나하나 실행하면서 만들어진다. 따라서, 선언적 함수를 사용할 경우 자바스크립트 코드의 실행 흐름을 예측하기 힘들어짐.
안전상 익명함수로 통일해서 사용하는 것이 좋음.


6장 객체
## 객체
객체는 배열과 마찬가지로 여러가지 자료를 한꺼번에 다루게 해주는 특별한 자료형.
원래 배열이 객체의 일종. (typeof([])를 하면 object가 나옴)

객체의 형태는 다음과 같음. 키에는 식별자를 사용함.(식별자의 조건: 1.숫자로 시작하지 않는다. 2.기호는 $와 _만 포함한다.)
const object = {
    키: 값,
    키: 값,
    키: 값,
    ...
}
"객체['키']" 또는 "객체.키" 통해 속성에 접근 가능

익명 함수: this 바인딩을 함.
화살표 함수: this 바인딩을 안 함.
** this 바인딩: this를 현재 객체와 연결하는 행위.

자바스크립트에서는 this.을 붙이지 않으면 객체 내부에 있는 속성이라고 생각 안함. this.을 꼭 붙여줘야 함.

# 객체 생성
처음 만들 때 같이 만드는 것 => 정적으로 생성
나중에 만드는 것 => 동적으로 생성

# 객체의 키와 값을 정적으로 생성
ex)
const pet = {
    name: '구름'
}

# 객체의 키와 값을 동적으로 생성
ex)
pet.color = 'brown'

# 객체의 키와 값을 동적으로 제거
delete 객체.속성
delete 객체['속성']
ex)
delete pet.color

** 앞서 배열에서 설명했듯이 객체 또한 힙에 생성되므로 const로 선언했더라도 값 추가 가능.
다만, 아예 다른 값을 대입하는 것은 불가. ex) pet = {} (X) , pet = '' (X)

# 기본 자료형 -> 스택에 값을 저장 -> 속성과 메서드를 가질 수 없음.
- 숫자
- 문자열
- 불

# 객체 자료형 -> 스택과 힙을 연결 -> 크기를 늘릴 수 있기 때문에 속성과 메서드를 가짐
- 함수
- 배열
- 객체
- 등등

typeof(함수) => 'function', 함수는 일급 객체(first-class object). 함수를 객체처럼 쓰는 언어는 "함수를 일급 객체(first-class object)로 다룬다"라고 표현.

# 기본 자료형을 객체 자료형으로 선언하기
const a = new Number(10)
const b = new String('문자열')
const c = new Boolean(true)
이렇게 만든 숫자, 불, 문자열은 기본 자료형 숫자, 불, 문자열과 똑같이 사칙연산과 비교 연산자 등을 사용할 수 있음.
typeof()로 확인 시, object 타입으로 나옴. 단순한 기본 자료형이 아니므로 이전과 다르게 속성을 가짐. 만약 new 키워드를 사용하지 않으면 자료형 변환 기능으로 사용됨.

Q. 궁금증! 이론적으로 기본 자료형은 속성과 메서드를 추가할 수 없는데 .length와 같은 속성과 메서드는 어떻게 사용할 수 있는 걸까?
A. 이론적으로는 기본 자료형은 속성과 메서드를 추가할 수 없고 기본 자료형이 속성과 메서드를 쓸 수 있는 이유는 "일시적으로 기본 자료형을 객체로 승급시키기 때문" 이다.
따라서, 기본 자료형의 경우 속성과 메소드를 사용할 수는 있지만 속성과 메소드를 추가로 가질 수는 없음.

# 프로토타입으로 메소드 추가하기
어떤 객체의 prototype이라는 속성이 바로 객체 전용 틀이라고 할 수 있음. prototype 객체에 속성과 메소드를 추가하면 모든 객체와 기본 자료형에서 해당 속성과 메소드를 사용할 수 있음.
ex)
Number.prototype.sample = 10    //sample 속성 추가

String prototype.contain = function (data) {    //contain 메소드 추가
    return this.indexOf(data) >= 0
}

## 기본 자료형과 연결된 객체의 주요 메소드
# Number 객체
변수.toFixed(n) : 소수점 아래 n번째 자릿수까지 반올림하여 출력
Number.isNaN(n) : NaN(Not a Number)인지 확인. ** NaN과 비교하면 모든 값이 false로 나오므로 isNaN() 메소드를 사용해서 NaN인지 확인해야 함.
Number.isFinite(n) : Infinity(무한)인지 확인

# String 객체
변수.trim() : 문자열 양쪽 끝의 공백 없애기
변수.indexOf(찾는 문자열) : 문자열과 일치하는 첫 번째 인덱스를 반환. 매개변수를 생략하면 "undefined"를 찾음. 찾는 문자열이 없다면 -1 반환.
변수.split(구분자) : 구분자로 구분된 문자열을 반환

# Math 객체
수학 상수 Math.PI, Math.E
Math.random() : 0 이상 1 미만의 랜덤한 숫자를 생성. 0 <= 결과 < 1의 범위만 생성.
Math.floor(n) : 내림을 통해 정수로 만들어 주는 함수
Math.ceil(n) : 올림을 통해 정수로 만들어 주는 함수
Math.round(n) : 반올림을 통해 정수로 만들어 주는 함수
Math.max(n1,n2,n3 ...) : 최대 정수를 구하는 함수
Math.min(n1,n2,n3 ...) : 최소 정수를 구하는 함수
Math.max(...[n1,n2,n3...]) : 배열을 매개변수 값으로 전달 할 경우, 전개 연산자를 사용해야 함.

# 외부 script 파일 읽어 들이기
<script src = "외부 파일 경로.js"></script>
HTML 파일은 위에서 아래로 태그를 읽어들이면서 차근차근 적절한 처리를 함.

## 다양한 외부 라이브러리
# Lodash 라이브러리
# Luxon, date-fns: 날짜와 시간을 다루는 라이브러리
# Handsontable: 웹 페이지에 스프레드시트를 출력하는 라이브러리
# D3.js, ChartJS: 그래프를 그릴 수 있는 라이브러리
# Three.js: 3차원 그래픽을 다루는 라이브러리

** CDN(Contents Delivery Network, 콘텐츠 전송 네트워크): 전 세계 여러 지역에 전송할 데이터를 창고처럼 준비해두고 사용자가 데이터를 요청했을 때 가장 가까운 지역에서 데이터를 전송해준다면 훨씬 빠르게 데이터를 전송할 수 있음.
** min 버전의 자바스크립트 파일은 자바스크립트 코드를 집핑(zipping)한 파일을 의미함.
CDN과 min 버전의 파일을 사용하면 script 태그의 src 속성에 그냥 링크를 입력해도 해당 파일을 매우 빠르게 다운로드 받아서 사용 가능.


## 객체와 배열 고급
# 객체 기본값을 지정하는 내용
# 과거(1) undefined가 아니면 object.status 값을 넣고 ,맞으면 '이상 없음'을 넣어라
object.status = object.status !== undefined ? object.status : '이상 없음'

** 과거(2),(3)의 경우, dog.status에 빈문자열 or 0과 같이 false로 변환되는 값이 오지 않을 것이라는 것이 확실해야 함!
그렇지 않으면 값을 넣었는데도 기본 값이 들어감.
# 과거(2)
object.status = object.status ? object.status : '이상 없음'
# 과거(3)
object.status = object.status || '이상없음'

# 현대(1) 첫번째 방법은 전개연산자 ...을 사용하는 방법
** 전개연산자를 뒤에 둬야 함! 왜? 순서대로 속성 값에 덮어씌워지기 때문! 예를 들어, 기존 object에 status 속성의 기본값이 있다면 object = {status: '이상 없음', ...object } 실행 시, status가 생성되고 object의 status로 값이 다시 덮어 씌워지면서 기존 object의 status 기본값을 지킬 수 있음.
** 반대로 object = { ...object, status: '이상 없음' }으로 실행하면 기존 object 객체 안의 status 값의 유무와 관계없이 무조건 status 속성 값이 '이상 없음'이 덮어씌워지.
object = {status: '이상 없음', ...object }

# 현대(2) 이게 가장 현대적인 코드
fun = function ({name, age, color, status = '이상 없음'}){
    return `${name} : ${age} : ${color} : ${status}`
}

## 다중 할당
# 배열 기반의 다중 할당
[식별자, 식별자, 식별자, ... ] = 배열
ex)
let [a,b] = [1,2]

# 객체 기반의 다중 할당
{ 속성 이름, 속성 이름 } = 객체
{ 식별자 = 속성 이름, 식별자 = 속성 이름 } = 객체
const { name, price } = object
const { a = name, b = price } = object

## 배열 전개 연산자
얕은 복사(=참조 복사): 복사했을 때 다른 이름이 붙음. 배열을 복사한 뒤, 하나의 배열에만 특정 값을 추가해도 두 배열의 값이 동일하게 출력됨.
'배열1 = 배열2' 를 통해 얕은 복사 가능.

깊은 복사(=클론을 만드는 것): 복사한 두 배열이 완전히 독립적으로 작동함.
전개 연산자 ...을 이용하여 '배열1 = [...배열2]' 를 통해 깊은 복사 가능.

전개 연산자를 사용하여 손쉽게 자료 추가 가능.
[...배열, 자료, 자료, 자료]

## 객체 전개 연산자
마찬가지로 객체도 깊은 복사를 할 때 전개 연산자 사용 가능. 전개 연산자를 사용해서 깊은 복사를 하면 두 객체가 독립적으로 동작하는 것을 볼 수 있음. '객체1 = 객체2'를 실행하면 얕은 복사가 됨.
{...객체}

객체 역시 전개 연산자를 사용하여 손쉽게 자료 추가 가능.
{...객체, 자료, 자료, 자료}










