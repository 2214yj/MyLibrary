3장 파이썬

* 인덴트
공식 가이드인 (PEP 8)에 따라 공백 4칸을 원칙으로 한다. 구글의 파이썬 가이드라인 또한 공백 4칸 들여쓰기가 원칙이다.

* 네이밍 컨벤션
파이썬의 변수명, 함수명 네이밍 컨벤션은 자바와 달리 각 단어를 밑줄(_)로 구분하여 표기하는 스네이크 케이스(Snake Case)를 따른다.
특히 파이썬은 파이썬다운 방식에 굉장한 자부심이 있어서, 카멜 케이스뿐만 아니라 자바 스타일로 코딩하는 것을 지양한다.

* 타입 힌트
파이썬은 대표적인 동적 타이핑 언어임에도, 타입을 지정할 수 있는 타입 힌트가 PEP 484 문서에 추가됐다. (파이썬 버전 3.5 이상에서 사용 가능)
파이썬 함수에서 다음과 같이 타입을 선언할 수 있다.
ex) def fn(a: int) -> bool:
        ...
이처럼 타입 힌트를 사용하게 되면 파라미터의 타입과 리턴값의 타입을 확실하게 알 수 있다.
이와 같이 명시적으로 선언하게 되면 가독성이 좋아지며 버그 발생 확률을 줄일 수 있다.
또한 온라인 코딩 테스트 시에는 mypy를 사용하면 타입 힌트에 오류가 없는지 자동으로 확인할 수 있다.
pip install mypy 명령어를 통해 설치할 수 있고 mypy {파일명.py}을 입력하여 오류가 발생하는지 확인 가능하다.

* 리스트 컴프리헨션
파이썬은 map, filter와 같은 함수형 기능을 지원하며 다음과 같은 람다 표현식도 지원한다.
ex) list(map(lambda x: x + 10, [1, 2, 3]))

컴프리헨션이란 기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문으로, 파이썬의 대표적인 특징이기도 하다.
람다 표현식에 map이나 filter를 섞어서 사용하는 것에 비해 가독성이 훨씬 높다.

* 제너레이터
제너레이터는 파이썬의 오래된 기능 중 하나로, 루프의 반복 동작을 제어할 수 있는 루틴 형태를 말한다.
제너레이터가 없다면 메모리 어딘가에 대량의 데이터를 보관해야 하지만, 제너레이터를 이용한다면 단순히 제네레이터만 생성해두고 필요할 때 언제는 숫자를 만들어낼 수 있다.
이때 yield 구문을 사용하면 제너레이터를 리턴할 수 있다. 기존의 함수는 return 구문을 맞닥뜨리면 값을 리턴하고 모든 함수의 동작을 종료한다.
그러나 yield 제너레이터가 여기까지 실행 중이던 값을 내보낸다는 의미로, 중간값을 리턴한 다음 함수는 종료되지 않고 계속해서 맨 끝에 도달할 때까지 실행된다.
만약 다음 값을 생성하려면 next()로 추출하면 된다.
아울러 제너레이터는 여러 타입의 값을 하나의 함수에서 생성하는 것도 가능하다.

* range
제너레이터의 방시을 활용하는 대표적인 함수로는 range()가 있다.
range() 함수는 주로 for 문에서 쓰이는데, range()는 range 클래스를 리턴하며, for 문에서 사용할 경우 내부적으로는 제너레이터의 next()를 호출하듯 매번 다음 숫자를 생성해내게 된다.
파이썬 2.x 버전까지는 range() 함수는 숫자를 미리 생성해서 리스트로 리턴하는 방식이었고 제너레이터를 리턴하는 방식은 xrange()라고 따로 존재했다.
리스트와 range 클래스의 메모리 점유율을 비교해보면 range 클래스의 메모리 점유율이 훨씬 더 적다.
이는 range 클래스에는 생성 조건만 보관하고 있기 때문이다.
미리 생성하지 않은 값은 인덱스에 접근이 안될 거라 생각할 수 있지만 인덱스로 접근 시에는 바로 생성하도록 구현되어 있기 때문에 리스트와 거의 동일한 느낌으로 불편 없이 사용할수 있다.

* enumerate
enumerate()는 '열거하다'는 뜻의 함수로 여러가지 자료형(list, set, tuple 등)을 인덱스를 포함한 enumerate 객체로 리턴한다.
enumerate()를 사용하여 인덱스와 값을 모두 한 번에 깔끔하게 처리할 수 있다.
ex) for i, v in enumerate(a):
        print(i,v)

* 나눗셈 연산자 '//'
// 연산자는 정수형을 나눗셈할 때 동일한 정수형을 결과로 리턴하면서 내림 연산자의 역할을 한다. (몫을 구하는 연산자이다.)
몫과 나머지를 동시에 구하려면 divmod() 함수를 사용하면 된다.
ex) divmod(5,3)     =>  (1,2)를 리턴, 몫과 나머지를 한 번에 구한다.

* print
실무에서는 print()를 활용하는 디버깅 방법을 추천하지 않지만 코딩 테스트 시에는 디버거를 사용하거나 TDD 방식으로 접근하기도 어렵기 때문에, 사실상 print()가 디버깅을 위해 제공되는 유일한 기능이다.
콤마로 값들을 구분하여 출력할 경우, 한 칸 공백이 디폴트로 설정되어 있으며 그대로 출력하면 띄어쓰기로 값을 구분해준다.
sep 파라미터로 구분자를 지정해 줄 수도 있다. ex) print('A1','B2', sep = ',')     =>  A1,B2
end 파라미터로 줄바꿈을 하지 않도록 설정을 할 수 있다.
리스트를 출력할 때는 join()으로 묶어서 처리한다. ex) print(' '.join(a))   =>  A B
format과 f-string(formated string literal)을 이용하여 출력 서식을 지정할 수 있다.
ex) print('{0}: {1}'.format(idx+1, fruit))
    print'{}: {}'.format(idx+1, fruit))
    print(f'{idx+1}: {fruit}')
특히, f-string 방식은 기존의 %를 사용하거나 .format을 부여하는 방식에 비해 훨씬 간결하고 직관적이며 속도도 빠르다.
주의할 점은 f-string은 파이썬 3.6버전 이상에서만 지원한다는 점이다.

* pass
아무것도 처리하지 않는 메소드의 경우, 오류를 발생한다. pass는 이런 오류가 발생하는 것을 막는 역할을 한다.
파이썬에서 pass는 Null 연산으로 아무것도 하지 않는 기능이다.
이처럼 아무 역할을 하지 않는 pass를 지정하면, 앞서 발생한 인덴트 오류 같은 불필요한 오류를 방지할 수 있다.

* locals
locals()는 로컬 심볼 테이블 딕셔너리를 가져오는 메소드로 업데이트 또한 가능하다.
이를 활용하면 로컬에 선언된 모든 변수를 조회할 수 있는 강력한 명령이므로 디버깅에 많은 도움이 된다.
특히 로컬 스코프에 제한해 정보를 조회할 수 있기 때문에 클래스의 특정 메소드 내부에서나 함수 내부의 로컬 정보를 잘못 조회해 선언한 부분이 없는지 확인하는 용도로 활용 가능하다.


* 코딩 스타일
좋은 코드에 정답은 없지만 각자가 원하는 방식을 택하면 된다. 그러나 많은 사람이 선호하는 방식은 있다.

* 변수명과 주석
저자의 개인적인 생각에 의하면 파이썬에서 간단한 주석을 부여하는 편이 가독성이 훨씬 높다.
또한 변수명도 마찬가지로 의미 없는 이름보다는 각각의 의미를 부여해 작명하고 스네이크 케이스로 작성하는 것이 좋다.
코딩 텟트 시 영어로 주석을 달아서 제출하는 편이 좀 더 프로페셔널하다는 인상을 줄 수 있다.

* 리스트 프리헨션
리스트 컴프리헨션은 그 강력함으로 인해 대부분 한 줄로 적게 되는 경우가 많은데 이 경우에도 가능한대로 다음과 같이 역할별로 줄 분을 하면 훨씬 가독성이 높아지고 이해하기 쉬워진다.
ex) strls = [
        strl[i:i+2].lower() for i in range(len(str1) - 1)
        if re.findall('[a-z]{2}', strl[i:i+2].lower()]
    ]

* 구글 파이썬 스타일 가이드
구글 파이썬 스타일 가이드는 구글에서 정한 스타일 가이드로, PEP 8에서는 설명하지 않는 좋은 코드를 위한 지침들이 여럿 있는 편이다.
특히 가독성을 높이기 위한 지침들이 많다.

함수으 기본값으로 가변 객체를 사용하지 않아야 한다. 함수가 객체를 수정하면 기본값이 변경되기 때문이다.
따라서 다음과 같이 기본값으로 []나 {}를 사용하는 것은 지양해야 한다. 대신 불변 객체를 사용한다. None을 명시적으로 할당하는 것도 좋은 방법이다.
ex) Yes: def goo(a, b=None):
            if b is None:
                b = []

True, False를 판별할 때는 암시적인 방법을 사용하는 편이 간결하고 가독성이 높다.
직접 값을 비교하는 편이 가독성이 좋다.
         (NO)                                   (YES)
    len(users) == 0                 =>          not users
    foo is not None and not foo     =>          foo == 0
    not i % 10                      =>          i % 10 == 0

가독성을 위해 최대 줄 길이는 80자로 하는 것이 좋다.






















Q. map이나 filter 대신 리스트 컴프리헨션을 사용하는 게 정말 더 좋을까?
