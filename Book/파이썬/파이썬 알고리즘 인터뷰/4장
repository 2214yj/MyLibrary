4장 빅오, 자료형

* 빅오
빅오는 점근적 실행 시간을 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나다.
점근적 실행 시간이란 입력값 n이 커질 때, 즉 입력값이 무한대를 향할 때 함수의 실행 시간의 추이를 의미한다.
입력의 크기가 충분히 클 때 알고리즘의 효율성에 따라 수행 시간이 크게 차이가 날 수 있다.

점근적 실행 시간은 달리 말하면 시간 복잡도라 할 수 있다.
시간 복잡도의 사전적 정의는 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도를 의미하며, 계산 복잡도를 표기하는 대표적인 방법이 바로 빅오다.
빅오로 시간 복잡도를 표현할 때는 최고차항만을 표기하며, 계수는 무시한다.
이처럼 시간 복잡도를 표기할 때는 입력값에 따른 알고리즘의 실행 시간의 추이만을 살피게 된다.

<빅오 표기법의 종류>
O(1): 입력값이 아무리 커도 실행 시간은 일정하다. 최고의 알고리즘이라 할 수 있다.
그러나 이와 같은 알고리즘을 찾기 어렵고 상수값이 상상 이상으로 크다면 사실상 일정한 시간의 의미가 없다.
따라서, 최고의 알고리즘이 될 수 있지만 그만큼 신중해야 한다.

O(log n): 로그는 매우 큰 입력값에도 크게 영향을 받지 않는 편이므로 웬만한 n의 크기에 대해서도 매우 견고하다.

O(n log n): 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 해당한다.
적어도 모든 수에 대해 한 번 이상은 비교해야 하는 비교 기반 정렬 알고리즘은 아무리 좋은 알고리즘 O(n log n)보다 빠를 수 없다.

O(n^2): 버블 정렬 같은 비효율적인 정렬 알고리즘이 이에 해당한다.

O(2^n): 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당한다. (n^2와 혼동하는 경우가 있는데 2^n이 훨씬 더 크다)

O(n!): 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제를 브루트 포스롤 풀이할 때가 이에 해당한다.
가장 느린 알고리즘으로 입력값이 조금만 커져도 웬만한 다항 시간 내에는 계산이 어렵다.

빅오는 시간 복잡도 외에도 공간 복잡도를 표현하는 데에도 널리 쓰인다.
알고리즘은 흔히 '사간과 공간이 트레이드오프'되는 관계이다. (실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다.)

* 상한과 최악
빅오(O)는 상한을 의미.
빅오베가(Ω)는 하한을 의미.
빅세타(θ)는 평균을 의미.
학계와 달리 업계에서는 빅세타와 빅오를 하나로 합쳐서 단순화해서 표현하려는 경향이 있다.
평균적인 시간보다는 상한 시간으로 단순화해서 주로 표현하는데, 매번 구분하는 것이 번거롭고 혼동되기도 하며 또한 상한으로만 표현하는 방법이 틀리지 않기 때문이다.

빅오 표기는 복잡한 함수 f(n)이 있을 경우, 이 함수의 실행 상한과 하한을 의미한다.
즉 가장 빨리 실행될 때(하한), 가장 늦게 실행될 때(상한)를 뜻하며 이 중 가장 늦게 실행될 떄를 빅오(O), 가장 빨리 실행될 떄를 빅오메가(Ω), 평균적으로는 빅세타(θ)로 지칭한다.
n이 작은 경우는 무시하며 빅오 표기법은 n이 매우 클 때의 전체적인 그림에 집중한다.

    " 빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다. "


* 분할 상환 분석
분할 상환 분석 등장 계기: 시간 또는 메모리를 석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로 분할 상환 분석 방법이 등장하는 계기가 됐디.
분할 상환 분석은 빅오와 함께 함수의 동작을 설명할 떄 중요한 분석 방법 중 하나다.
어쩌다 한 번 발생하는 현상으로 인해 시간 복잡도를 단정 짓는 것은 지나치게 비관적이며 정확하지도 않다.
따라서 이 경우 '분할 상환' 또는 '상각'이라고 표현하는 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산할 수 있다.


* 병렬화
일부 알고리즘들은 병렬화로 실행 속도를 높일 수 있다.
병렬화를 이용하면 속도는 느리지만 한번에 많은 양을 나를 수 있다.
딥러닝 알고리즘을 비롯해 병렬 연산이 가능한 알고리즘들은 최근에 큰 주목을 받고 있다.
알고리즘 자체의 시간 복잡도 외에도 알고리즘이 병렬화가 가능한지는 근래에 알고리즘의 우수성을 평가하는데 매우 중요한 척도 중 하나이기도 하다.



** 자료형
<파이썬의 주요 자료형>
숫자                 =>  실수 (class float)
(class None Type)   =>  정수형   =>   정수(class int)
                                =>   불리언(class bool)

집합형   =>    집합(class set)

매핑    =>   딕셔너리(class dict)

시퀀스   =>   가변   =>   리스트(class list)
        =>   불변   =>   문자열(class str)
                   =>   튜플(class tuple)
                   =>   바이트(class bytes)


* 숫자
버전 2.4부터는 int가 충분하지 않으면 자동으로 long 타입으로 변경되는 구조가 됐으며 덕분에 C와 달리 오버플로(Overflow)가 발생하는 일이 사라졌다.
버전 3부터는 아예 int 단일형으로 통합됐다.
int는 임의 정밀도를 지원하며, 더 이상 파이썬에서 고정 정밀도 정수형은 지원하지 않게 되었다.

# 임의정밀도 정수형이란 무제한 자릿수를 제공하는 정수열. 어떻게 이게 가능할까?
자릿수를 단위로 쪼개어 배열 형태로 표현함으로써 무제한 자릿수를 제공할 수 있다.

bool은 논리 자료형인데 파이썬에서는 내부적으로 1(True)과 0(False)으로 처리되는 int의 서브 클래스다.
int는 object의 하위 클래스이기도 하기 때문에 결국 object > int > bool과 같은 구조를 띈다.


* 매핑
매핑 타입은 키와 자료형으로 구성된 복합 자료형이며, 파이썬에 내장된 유일한 매핑 자료형은 바로 딕셔너리이다.

* 집합
집합 자료형인 set은 중복된 값을 갖지 않는 자료형이다.
set은 입력 순서가 유지되지 않으며, 중복된 값이 있을 경우 하나의 값만 유지한다.

* 시퀀스
시퀀스는 우리말로 '수열', 즉 어떤 특정 대상의 순서 있는 나열을 뜻한다.
파이썬에서는 list라는 시퀀스 타입이 사실상 배열의 역할을 수행한다.
시퀀스는 값을 변경할 수 없는 '불변'과 값을 변경할 수 있는 '가변'으로 구분 가능하다.
불변 타입에는 str, tuple, bytes가 해당되는데 한번 이 타입으로 선언되는 값은 변경할 수 없다.
str 변수는 값을 변경할 수 있는 것처럼 보이지만 실제론 다른 객체를 참조함으로써 값을 변경할 수 있는 것처럼 보인는 것 뿐이다. (str 변수에 값을 재할당하고 id를 출력해보면 id 값이 변경된 것을 확인 가능하다.)

반면에 list는 가변이다. 리스트는 자유롭게 값을 추가, 삭제할 수 있는 동적 배열이다.

* 원시 타입
C나 자바 등 대표적인 프로그래밍 언어들은 다양한 원시 타입(primitive Type)을 제공한다. 원시 타입은 메모리에 정확하게 타입 크기만큼의 공간을 할당하고 그 공간을 오로지 값으로 채워 넣는다.
C나 자바는 성능에 대한 우선순위가 높은 언어다. 떄문에 좀 더 하드웨어에 가까운 원시 타입을 별도로 제공하며, 원시 타입으로 구현했을 때 훨씬 더 빠른 속도로 실행할 수 있다.
파이썬은 원시 타입을 지원하지 않는다!
파이썬은 애초에 편리한 기능 제공에 우선순위를 둔 언어인만큼 느린 속도와 더 많은 메모리를 차지하더라도 훨씬 더 다양한 기능을 제공할 수 있는 객체에 관심을 두고 있다.
따라서, 파이썬은 원시 타입의 속도를 포기하는 대신 객체의 다양한 기능과 편의 성을 택했다.

* 객체
파이썬은 모든 것이 객체다. 이중에서 크게 불변 객체와 가변 객체로 구분할 수 있다.

<파이썬 자료형의 불변 객체 여부>
    (클래스)       (설명)                            (불변 객체)
    bool        부울                                  O
    int         정수                                  O
    float       실수                                  O
    list        리스트                                 X
    tuple       리스트와 튜플의 차이는 불변여부이며           O
                이 외에는 거의 동일하다.
    str         문자                                  O
    set         중복된 값을 갖지 않는 집합 자료형            X
    dict        딕셔너리                               X

* 불변 객체
파이썬은 모든 것이 객체다. 파이썬에서 변수를 할당하는 작업은 해당 객체에 대해 참조를 한다는 의미.
심지어 문자와 숫자도 모두 객체이다.
만약 원시 타입이라면 각각의 값들은 각 메모리의 다른 영역에 위치할 것이다.
그러나 파이썬은 모든 것이 객체이므로 같은 값을 가지고 있는 변수의 메모리 상에 위치한 객체의 주소를 얻어오는 id() 함수를 실행한 결과는 놀랍게도 모두 동일하다.
값을 담고 있는 변수는 사실 참조일 뿐이고 실제로 값을 갖고 있는 int와 str은 모두 불변 객체다.
한번 값을 담아두면 더 이상 값을 변경할 수 없으므로 read-only 용도로 사용하거나 dict 키 또는 set의 값으로도 사용할 수 있다.

(정라) => 불변 객체는 변수가 참조 중인 객체의 값이 변하지 않으며, 다른 변수가 참조하더라도 그 변수의 값 또한 변경되지 않는다.
불변 객체를 참조 중인 변수에 연산을 하면 원래 참조하던 객체의 값이 바뀌는 대신, 다른 객체를 참조한다. (id() 함수로 변수의 메모리 상에 위치한 객체의 주소를 확인해보면 변수의 값이 변화할 때마다 id() 값이 달라지는 것을 확인 가능)

* 가변 객체
가변 객체는 다른 변수가 참조하고 있을 때 그 변수의 값 또한 변경된다는 이야기이다.

(정리) => 가변 객체는 변수가 참조 중인 객체의 값이 변하기 때문에 다른 변수가 참조하면 그 변수의 값 또한 변경된다.
가변 객체를 참조 중인 변수에 연산을 하면 원래 참조하던 객체의 값이 바뀐다. (id() 함수로 변수의 메모리 상에 위치한 객체의 주소를 확인해보면 연산을 수행하더라도 id() 값이 같은 것을 확인 가능)

* C++ 참조와 비교
한 가지 주의할 점은 C++의 참조(Reference) 방식은 파이썬의 참조 할당 방식과는 조금 다르다는 점이다.
C++에서 참조 변수는 파이썬과 동일하게 참조를 갖는다. 또한 참조 변수에 값을 할당하면 참조의 대상 또한 할당된 값으로 변경된다.
그러나 파이썬은 다르다. 참조를 통해 두 변수가 동일한 메모리 주소를 가리키게 됐지만 하나의 변수에 새로운 값을 할당하게 되면 새로운 객체를 참조하게 되며 더 이상 같은 객체를 참조하지 않는다.
불변 객체는 값의 변경이 불가능하기 때문에 이처럼 참조 변수에서 값을 조작할 수 있는 방법이 없다.
그러나 가변 객체를 참조하고 있다면 참조 변수에서 값을 조작하는 경우 참조 대상의 변수도 변경할 수 있게 된다. 다만, 이 경우에도 = 연산자로 재할당을 하게 되면 다른 ID가 되므로 주의가 필요하다.

* is와 ==
is는 id() 값을 비교하는 함수다. None은 널(null)로서 값 자체가 정의되어 있지 않으므로 ==로 비교가 불가능하고 is로만 비교가 가능하다.
==는 값을 비교하는 연산자다.
ex) a == list(a)    =>  True
    a is list(a)    =>  False
값은 동일하지만 list()로 한 번 더 묶어주면, 별도의 객체로 복사가 되고 다른 ID를 갖게 되므로 is는 False가 된다.

또한 copy.deepcopy()로 복사한 결과 또한 값은 같지만 ID는 다르기 때문에 ==로 비교하면 True, is로 비교할 경우 False가 된다.

* 속도
파이썬의 객체 구조는 잘 설계되어 있고 매우 편리하고 강력한 기능을  제공하지만 문제는 속도다.
파이썬의 객체 구조는 파이썬이 다른 언어들에 비해 느린 중요한 이유 중 하나이기도 하다.
파이썬의 과학 계산 모듈인 넘파이는 C로 만든 모듈이며 내부적으로 리스트를 C의 우너시 타입으로 처리하기 때문에 속도가 빠르다.

* 자료구조, 자료형, 추상 자료형
자료구조: 데이터에 효율적으로 접근하고 조작하기 위한 데이터의 조직, 관리, 저장 구조를 말한다. 일반적으로 원시 자료형을 기반으로 하는 배열, 연결 리스트, 객체 등을 말하며, 자료형의 관점에서 보자면 여러 원시 자료형을 조합한 자료구조는 복합 자료형이 된다.
자료형: 컴파일러 또는 인터프리터에게 프로그래머가 데이터를 어떻게 사용하는지를 알려주는 일종의 데이터 속성이다. 일반적으로 정수, 실수, 문자열 등 해당 언어에서 지원하는 원시 자료형까지 포함하는 모든 자료의 유형을 말한다.
추상 자료형(ADT): 자료형에 대한 수학적 모델을 지칭. 해당 유형의 자료에 대한 연산들을 명기한 것이다. ADT는 행동만을 정의할 뿐 실제 구현 방법은 명시하지 않는다.







