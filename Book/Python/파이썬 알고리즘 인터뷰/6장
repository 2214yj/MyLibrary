6장 문자열 조작

문자열 조작이란 문자열을 변경하거나 분리하는 등의 여러 과정을 말한다.

문제1. 유효한 팰린드롬
주어진 문자열이 팰린드롬(앞뒤가 똑같은 단어나 문장으로, 뒤집어도 같은 말이 되는 단어 또는 문장)인지 확인하라. 대소문자를 구분하지 않으며, 영문자와 숫자만을 대상으로 한다.

예제1)
입력: "A man, a plan, a canal: Panama"
출력: "true"

풀이1) 리스트로 변환
def isPalindrome(self, s: str) -> bool:
    strs = []
    for char in s:
        if char.isalnum():
            strs.append(char.lower())

    while len(strs) > 1:
        if strs.pop(0) != strs.pop():
            return False
    return True
=> 문자열의 문자들을 isalnum()을 이용해 영문자와 숫자인 문자만 판별하여 새로운 리스트를 만들었다.
pop() 함수를 통해 리스트의 맨 앞과 맨 뒤의 값을 매칭해 나가면서 결과를 도출한다.

풀이2) 데크 자료형을 이용한 최적화 (Deque를 명시적으로 선언하면 속도를 개선할 수 있다)
def isPalindrome(self, s: str) -> bool:
    strs: Deque = collections.deque()

    for char in s:
        if char.isalnum():
            strs.append(char.lower())

    while len(strs) > 1:
        if sttrs.popleft() != strs.pop():
            return False

    return True
=> 자료형을 Deque로 변경하는 것만으로도 성능이 5배 가까이 개선되었다.
리스트의 pop(0)은 O(n)인 데 반해, Deque의 popleft()는 O(1)이기 때문이며, 각각 n번씩 반복하면 리스트 구현은 O(n²), 데크 구현은 O(n)으로 성능 차이가 크다.

풀이 3) 슬라이싱 사용
def isPalindrome(self, s: str) -> bool:
    s = s.lower()
    s = re.sub('[^a-z0-9]'. '', s)

    return s = s[::-1]
=> 여기서는 별달리 알고리즘이라 부를 만한 게 없다. 정규식으로 불필요한 문자를 필터링하고, 문자열을 조작할 수 있는 파이썬의 슬라이싱(Slicing)을 사용했다.
앞서 풀이에서는 isalnum()으로 모든 문자를 일일이 점검했지만 여기서는 문자열 전체를 한 번에 영숫자만 걸러내도록 정규식으로 처리했다.
또한 파이썬은 문자열을 배열이나 리스트처럼 자유롭게 슬라이싱할 수 있는 좋은 기능을 제공하며, [::-1]을 이용하면 뒤집을 수 있다. (코드가 훨씬 더 줆어듦은 물론, 내부적으로 C로 빠르게 구현되어 있어 훨씬 더 좋은 속도를 기대할 수 있다.)
이 경우, 앞선 풀이2에 비해 약 2배 정도 속도가 개선되었다.

** 문자열 슬라이싱
파이썬에서는 문자열 슬라이싱이라는 매우 빠르고 편리한 기능을 제공한다.
위치를 지정하면 해당 위치의 배열 포인터를 얻게 되며 이를 통해 연결된 객체를 찾아 실제 값을 찾아내는데, 이 과정은 매우 빠르게 진행되므로 문자열을 조작할 때는 항상 슬라이싱을 우선으로 사용하는 편이 속도 개선에 유리하다.


문제2. 문자열 뒤집기
문자열을 뒤집는 함수를 작성하라. 입력값은 문자 배열이며, 리턴 없이 리스트 내부를 직접 조작하라.

예제1)
입력: ["h","e","l","l","o"]
출력: ["o","l","l","e","h"]

풀이1) 투 포인터를 이용한 스왑
def reverseString(self, s: List[str]) -> None:
    left, right = 0, len(s) -1
    while left < right:
        s[left], s[right] = s[right], s[left]
        left += 1
        right -= 1
=> 두개의 포인터를 이용해 범위를 조정해가며 풀이하는 방식.
점점 더 범위를 좁혀 가며 스왑하는 형태로 풀이할 수 있다.

풀이2) 파이썬다운 방식
def reverseString(self, s: List[str]) -> None:
    s.reverse()
=> reverse()는 리스트에만 제공된다.
만약 입력값이 문자열이라면 앞서 살펴본 바와 같이 문자열 슬라이싱을 사용할 수 있다. 슬라이싱은 리스트에도 사용할 수 있으며 성능 또한 매우 좋다.
s = s[::-1] 풀이는 리트 코드에서는 오류가 발생한다. 원래는 정상적으로 처리되어야 하지만 이 문제는 공간 복잡도를 O(1)로 제한하다 보니 변수 할당을 처리하는 데 다소 제약이 있다.
s[:] = s[::-1]와 같이 트릭을 사용하면 잘 동작한다.


문제3. 로그 파일 재정렬
로그를 재정렬하라. 기준은 다음과 같다.
1. 로그의 가장 앞 부분은 식별자다.
2. 문자로 구성된 로그가 숫자 로그보다 앞에 온다.
3. 식별자는 순서에 영향을 끼치지 않지만, 문자가 동일한 경우 식별자 순으로 한다.
4. 숫자 로그는 입력 순서대로 한다.

예제1)
입력: logs = ["dig1 8 1 5 1", "let1 art can", "dig2 3 6", "let2 own kit dig", "let3 art zero"]
출력: ["let1 art can", "let3 art zero", "let2 own kit dig", "dig1 8 1 5 1", "dig2 3 6"]

풀이1) 람다와 + 연산자를 이용
def reorderLogFiles(self, logs: List[str]) -> List[str]:
    letters, digits = [], []
    for log in logs:
        if log.split()[1].isdigit():
            digits.append(log)
        else:
            letters.append(log)
    letters.sort(key=lambda x: (x.split()[1:], x.split()[0]))
    return letters + digits
=> isdigit()을 이용하여 숫자 여부인지를 판별해 구분해본다.
숫자로 변환 가능한 로그는 digits에, 그렇지 않은 경우 문자 로그는 letters에 추가된다.
이제 문자 로그는 letters에 모두 모였으므로 lambda 함수를 이용하여 다음과 같이 이를 제대로 정렬하기만 하면 된다.
여기서는 식별자를 제외한 문자열 [1:]을 키로 하여 정렬하며, 동일한 경우 후순위로 식별자[0]를 지정해 정렬되도록 람다 표현식을 이용해 정렬했다.

** 람다 표현식
람다 표현식이란 식별자 없이 실행 가능한 함수를 말하며, 함수 선언 없이도 하나의 식으로 함수를 단순하게 표현할 수 있다.
그러나 이 책에서는 람다 표현식보다 훨씬 더 간결하고 가독성이 높은 리스트 컴프리헨션을 주로 사용할 예정이다. 그러나 이 문제처럼 꼭 필요한 경우에는 람다로 풀이하는 게 더 편하다.
람다 표현식을 사용하면 별도의 함수를 선언하지 않고도 간단한 함수를 선언한 것처럼 쉽게 처리할 수 있지만 람다 표현식은 코드가 길어지고 map이나 filter와 같이 함께 섞어서 사용하기 시작하면 가독성이 매우 떨어질 수 있으므로 주의가 필요하다.


문제4. 가장 흔한 단어
금지된 단어를 제외한 가장 흔하게 등장하는 단어를 출력하라. 대소문자 구분을 하지 않으며, 구두점(마침표, 쉼표 등) 또한 무시한다.

예제1)
입력: paragraph = "Bob hit a ball, the hit BALL flew fat after it was hit."
banned = ["hit"]
출력: "ball"

풀이1) 리스트 컴프리헨션, Counter 객체 사용





<추가 복습 포인트!>
isalpha(): 문자열이 영어 혹은 한글로 되어있으면 참 리턴, 아니면 거짓 리턴.
isalnum(): 문자열이 영어, 한글 혹은 숫자로 되어있으면 참 리턴, 아니면 거짓 리턴.

isdecimal(), isdigit(), isnumeric()의 차이:
3²에서 ²는 특수문자이지만 isdigit() 함수와 isnumeric() 함수로는 True가 반환된다.
하지만 isdecimal() 함수로는 False가 반환된다.

isdigit() 함수는 단일 글자가 '숫자' 모양으로 생겼으면 무조건 True를 반환하는 함수. 즉, 숫자처럼 생긴 '모든 글자'를 숫자로 친다.
그에 비해 isdecimal() 함수는 주어진 문자열이 int형으로 변환이 가능한지 알아내는 함수이기 때문에 특수문자 중 숫자모양을 숫자로 치지않는다.
isnumeric() 함수는 숫자값 표현에 해당하는 문자열까지 인정한다. 제곱근 및 분수, 거듭제곱 특수문자도 isnumeric() 함수는 True를 반환하는 것을 알 수 있다.
즉, isdigit() > isnumeric() > isdecimal() 순서대로 유연하게 숫자로 인식함.
출처: https://it-neicebee.tistory.com/43?category=890500 [IT's Portfolio:티스토리]