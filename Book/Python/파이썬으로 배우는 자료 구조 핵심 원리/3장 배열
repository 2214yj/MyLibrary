3장 배열

** 동적 배열
초기 배열은 같은 데이터 타입을 가진 변수 집합이었지만 C언어를 제외한 거의 대부분의 언어가 초기 형태의 배열이 아닌 동적 배열을 지원한다.
메모리에서 데이터를 저장하는 3군데 영역:
    - 스택: 실제 스택 프레임이 쌓이는 메모리 공간. 스택 프레임을 할당하려면 미리 할당될 스택 프레임의 크기를 알고 있어야 한다. 그래서 스택 영역에 배열을 만들기 위해서는 반드시 고정된 크기로 만들어야 했다.
    - 힙: 변수의 생성 시기와 소멸 시기를 프로그래머가 결정할 수 있는 메모리가 동적으로 할당되는 영역.
        힙 영역은 프로그래머가 원하는 만큼 크기를 할당받을 수 있기에 일단 필요한 만큼 할당 받아 데이터를 저장하다가, 많은 메모리가 필요한 순간이 오면 더 큰 공간을 확보하여 이전 배열 요소를 모두 복사한 후 새로운 데이터를 삽입할 수 있다.
        C++의 vector, 자바의 ArrayList, 파이썬의 리스트가 동적 배열이다.

동적 배열: 힙 영역에 저장되는 배열.

< 파이썬으로 동적 배열의 ADT 작성해보기>
1.  Array.is_empty() -> Boolean
: 리스트가 비어 있으면 TRUE, 아니면 FALSE 반환
>>> bool(li)

2. Array.add_last(element)
: 리스트의 마지막에 원소 추가
>>>li.append(5)

3. Array.insert(index, element)
: 리스트의 index 위치에 element 원소 삽입
>>>li.insert(1,4)

4. Array[index] -> element
: 인덱싱(Indexing), 인덱스에 위치한 원소 반환


5. Array.remove_last() -> element
: 리스트의 마지막 원소를 삭제한 후 반환
>>>li.pop()

6. Array.remove(index) -> element
: 인덱스에 위치한 원소를 삭제하고 반환
>>>li.pop(1)




** 지역성의 원리와 캐시
베열의 중요한 특징은 배열이 메모리상에서 물리적, 선형적으로 이어져 있다는 것이다.
배열의 장점은 지역성의 원리와 캐시를 알아야 이해할 수 있다.

시간 지역성: 한번 접근한 변수는 계속해서 접근할 가능성이 높다.
공간 지역성: 이번에 접근한 변수는 이전에 접근한 변수 근처에 있을 가능성이 높다.

이런 지역성의 원리가 CPU와 메인 메모리 사이에 캐시를 두게 된 이유이다.
메인 메모리에 있는 변수는 연산을 하기 전과 후에 반드시 레지스터를 거친다. 이에 따른 비효율성을 줄이기 위해 캐시를 고안하게 되었다.
캐시는 CPU와 메인 메모리 사이에 위치해 있다.
CPU와 메인 메모리 사이에 성능이 빠른 버퍼(캐시)를 두어 비효율성을 줄이기 위함.

CPU가 필요한 변수를 캐시에 요청하면 캐시에 CPU가 요청한 변수가 없다면 캐시는 메인 메모리에 변수의 값을 요청한다.
그런데 이때, 변수의 값만 가져오는 것이 아니라 주변 변수까지 한꺼번에 가져온다.
배열은 메모리에서 선형적으로 이어져 있기 때문에 캐시 히트가 발생하기 좋은 최적의 조건이다.

CPU가 캐시에 요청했는데 요청한 데이터가 없는 경우 -> "캐시 미스"
요청한 데이터가 있는 경우 -> "캐시 히트"



** 인덱싱: 데이터에 빠르게 접근한다!
배열에서는 인덱싱(Indexing)을 이용하여 데이터에 접근한다.
배열의 요소가 메모리에 선형적으로 존재하기 때문에 인덱싱은 다음과 같은 간단한 수식의 연산만으로도 쉽게 데이터에 접근할 수 있다.
    데이터 주소 값 = 배열의 첫 주소 값 + (데이터 크기 * 인덱스)

이 수식은 한번의 연산으로도 값에 접근할 수 있기 때문에 빅오는 O(1)이다.



** 동적 배열에서 데이터의 삽입과 삭제1 (데이터를 배열의 마지막에 추가하거나 삭제하는 연산)
추가: 배열에 요소가 채워질 공간이 충분하다면 추가하려는 데이터를 배열의 마지막 요소 다음에 추가하면 된다. O(1)
삭제: 단순히 동적 배열에서 요소 개수를 나타내는 size 변수를 1 줄이면 된다. O(1)

그러나 문제는 "배열이 가득 차 있을 때" 이다.
추가: 충분한 공간을 다시 확보하고 기존 배열 요소를 모두 복사한 후 새로운 데이터를 추가해야 한다. 빅오가 데이터 개수만큼 복사해야 하므로 O(n)

즉, size가 1~(capacity-1)일 때는 O(1)이고 size가 capacity일 때는 O(n)이다.



** 동적 배열에서 데이터의 삽입과 삭제2 (데이터를 배열의 중간에 삽입하거나 삭제하는 연산)
추가: 맨 처음에 삽입해야 할 경우 동적 배열에서는 삽입하기 위해 이미 있는 요소들을 모두 한 번씩 뒤로 옮겨야 한다. O(n)
삭제: 맨 처음 요소를 삭제해야 할 경우 모든 요소를 한 번씩 앞으로 옮겨야 한다. O(n)
