11장 해시 테이블

해시테이블 또는 해시 맵은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추상 자료형(ADT)을 구현하는 자료구조다.

해시 테이블의 가장 큰 특징은 대부분의 연산이 분할 상환 분석에 따른 시간 복자도가 O(1)이라는 점이다.
덕분에 데이터 양에 관계 없이 빠른 성능을 기대할 수 있다는 장점이 있다.

* 해시
해시 함수란 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수를 말한다.

해시 테이블의 핵심은 해시 함수다.
해시 테이블을 인덱싱하기 위해 이처럼 해시 함수를 사용하는 것을 해싱이라 하며, 해싱은 정보를 가능한 한 빠르게 저장하고 검색하기 위해 사용하는 중요한 기법 중 하나다.
해싱은 최적의 검색이 필요한 분야에 사용되며, 심볼 테이블 등의 자료구조를 구현하기에도 적합하다.
이외에도 해시 함수는 체크섬, 손실 압축, 무작위화 함수, 암호 등과도 관련이 깊으며 때로는 서로 혼용되기도 한다.
그러나 어느 정도는 개념이 겹치긴 하지만, 서로 용도와 요구사항이 다른 만큼 각각 다르게 설계되고 최적화된다.
성능 좋은 해시 함수들의 특징은 다음과 같다.
    - 해시 함수 값 충돌의 최소화
    - 쉽고 빠른 연산
    - 해시 테이블 전체에 해시 값이 균일하게 분포
    - 사용할 키의 모든 정보를 이용하여 해싱
    - 해시 테이블 사용 효율이 높을 것

여러 번 충돌한다는 것은 그만큼 추가 연산을 필요로 하기 때문에 가급적 충돌은 최소화하는 것이 좋다.

로드 팩터: 로드 팩터란 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것이다.
        load factor = n/k
    로드 팩터 비율에 따라서 해시 함수를 재작성해야 될지 또는 해시 테이블의 크기를 조정해야 할지를 결정한다.
    또한 이 값은 해시 함수가 키들을 잘 분산해 주는지를 말하는 효율성 측정에도 사용된다.
    자바 10에서는 해시맵의 디폴트 로드 팩터를 0.75로 정했으며 '시간과 공간 비용의 적절한 절충안'이라고 얘기한다.
    일반적으로 로드 팩터가 증가할수록 해시 테이블의 성능은 점점 감소하게 되며, 자바 10의 경우, 0.75를 넘어설 경우 동적 배열처럼 해시 테이블의 공간을 재할당한다.

해시 함수: 해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것을 해싱(Hashing)이라고 한다.
    해싱에는 다양한 알고리즘이 있으며, 최상의 분포를 제공하는 방법은 데이터에 따라 제각각이다.
    책에서는 가장 단순하면서도 널리 쓰이는 정수형 해싱 기법인 모듈로 연산을 이용한 나눗셈 방식 하나만 살펴보고 있다.

충돌: 아무리 좋은 해시 함수라도 충돌은 발생하게 된다.

개별 체이닝: 해시 테이블의 기본 방식이기도 한 개별 체이닝은 충돌 발생 시 연결 리스트로 연결하는 방식이다.
    이처럼 기본적인 자료구조와 임의로 정한 간단한 알고리즘만 있으면 되므로, 개별 체이닝 방식은 인기가 높다.
    원래 해시 테이 구조의 원형이기도 하며 가장 전통적인 방식으로, 흔히 해시 테이블이라고 하면 바로 이 방식을 말한다.
    간단한 원리를 요약하자면 다음과 같다.
        1. 키의 해시 값을 계산한다.
        2. 해시 값을 이용해 배열의 인덱스를 구한다.
        3. 같은 인덱스가 있다면 연결 리스트로 연결한다.
    잘 구현한 경우 대부분의 탐색은 O(1)이지만 최악의 경우, 즉 모든 해시 충돌이 발생했다고 가정할 경우에는 O(n)이 된다.

오픈 어드레싱: 오픈 어드레싱 방식은 충돌 발생 시 탐사를 통해 빈 공간을 찾아나서는 방식이다.
    사실상 무한정 저장할 수 있는 체이닝 방식과 달리, 오픈 어드레싱 방식은 전체 슬롯의 개수 이상은 저장할 수 없다.
    충돌이 일어나면 테이블 공간 내에서 탐사(Probing)를 통해 빈 공간을 찾아 해결하며, 이 때문에 개별 체이닝 방식과 달리, 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없다.
    여러가지 오픈 어드레싱 방식 중에서 가장 간단한 방식인 선형 탐사(Linear Probing) 방식은 충돌이 발생할 경우 해당 위치부터 순차적으로 탐사를 하나씩 진행한다.
    특정 위치가 선점되어 있으면 바로 그다음 위치를 확인하는 식이다. 이렇게 탐사를 진행하다가 비어 있는 공간을 발견하면 삽입하게 된다. 가장 가까운 다음 빈 위치를 탐사해 새 키를 삽입한다.
    이처럼 선형 탐사 방식은 구현 방법이 간단하면서도, 의외로 전체적인 성능이 좋은 편이기도 하다.

    선형 탐사의 한 가지 문제점은 해시 테이블에 저장되는 데이터들이 고르게 분포되지 않고 뭉치는 경향이 있다는 점이다.
    해시 테이블 여기저기에 연속된 데이터 그룹이 생기는 이러한 현상을 클러스터링(Clustering)이라 하는데, 클러스터들이 점점 커지게 되면 인근 클러스터들과 서로 합쳐지는 일이 발생한다.
    그렇게 되면 해시 테이블의 특정 위치에는 데이터가 몰리게 되고, 다른 위치에는 상대적으로 데이터가 거의 없는 상태가 될 수 있다.
    이러한 클러스터링 현상은 탐사 시간을 오래 걸리게 하며, 전체적으로 해싱 효율을 떨어뜨리는 원인이 된다.

    오픈 어드레싱 방식은 버킷 사이즈보다 큰 경우에는 삽입할 수 없다.
    따라서, 일정 이상 채워지면, 즉 기준이 되는 로드 팩터 비율을 넘어서게 되면, 그로스 팩터(Growth Factor)의 비율에 따라 더 큰 크기의 또 다른 버킷을 생성한 후 여기에 새롭게 복사하는 리해싱(Rehashing) 작업이 일어난다.
    이는 동적 배열에서 공간이 가득 찰 경우, 더블링으로 새롭게 복사해서 옯겨가는 과정과 유사하다.

* 언어별 해시 테이블 구현 방식
리스트와 함께 파이썬에서 가장 흔하게 쓰이는 자료형인 딕셔너리는 해시 테이블로 구현되어 있다.
파이썬은 해시 테이블 충돌 시 오픈 어드레싱 방식으로 구현되어 있다. 체이닝 시 malloc으로 메모리를 할당하는 오버헤드가 높아 오픈 어드레싱을 택했다.
또한 [Beautiful Code] 책에서 앤드큐 커클링에 따르면 연결 리스트를 만들기 위해서는 추가 메모리 할당이 필요하고, 추가 메모리 할당은 상대적으로 느린 작업이기 떄문에 택하지 않았다고 기술했다.

오픈 어드레싱의 한 방식인 선형 탐사 방식은 일반적으로 체이닝에 비해 성능이 더 좋다.
그러나 글롯의 80% 이상이 차게 되면 급격한 성능 저하가 일어나며, 체이닝과 달리 전체 슬롯의 전체 개수 이상, 즉 로드 팩터 1 이상은 저장할 수 없다.
빈 공간을 탐사하는 선형 탐사 방식은 공간이 찰수록 탐사에 점점 더 오랜 시간이 걸리며, 가득 차게 될 경우 더 이상 빈 공간을 찾을 수 없기 때문이다.
따라서, 최근의 루비나 파이썬 같은 모던 언어들은 오픈 어드레싱 방식을 택해 성능을 높이는 대신, 로드 팩터를 작게 잡아 성능 저하 문제를 해결한다.
파이썬의 로드 팩터는 0.66으로 자바보다 작으며 루비는 0.5로 훨씬 더 작다.


문제28. 해시맵 디자인
다음의 기능을 제공하는 해시맵을 디자인하라.
- put(key, value): 키, 값을 해시맵에 삽입한다. 만약 이미 존재하는 키라면 업데이트 한다.
- get(key): 키에 해당하는 값을 조회한다. 만약 키가 존재하지 않는다면 -1을 리턴한다.
- remove(key): 키에 해당하는 키, 값을 해시맵에서 삭제한다.

풀이1) 개별 체이닝 방식을 이용한 해시 테이블 구현
import collections


# Definition for singly-linked list.
class ListNode:
    def __init__(self, key=None, value=None):
        self.key = key
        self.value = value
        self.next = None


class MyHashMap:
    # 초기화
    def __init__(self):
        self.size = 1000
        self.table = collections.defaultdict(ListNode)

    # 삽입
    def put(self, key: int, value: int) -> None:
        index = key % self.size
        # 인덱스에 노드가 없다면 삽입 후 종료
        if self.table[index].value is None:
            self.table[index] = ListNode(key, value)
            return

        # 인덱스에 노드가 존재하는 경우 연결 리스트 처리
        p = self.table[index]
        while p:
            if p.key == key:
                p.value = value
                return
            if p.next is None:
                break
            p = p.next
        p.next = ListNode(key, value)

    # 조회
    def get(self, key: int) -> int:
        index = key % self.size
        if self.table[index].value is None:
            return -1

        # 노드가 존재할때 일치하는 키 탐색
        p = self.table[index]
        while p:
            if p.key == key:
                return p.value
            p = p.next
        return -1

    # 삭제
    def remove(self, key: int) -> None:
        index = key % self.size
        if self.table[index].value is None:
            return

        # 인덱스의 첫 번째 노드일때 삭제 처리
        p = self.table[index]
        if p.key == key:
            self.table[index] = ListNode() if p.next is None else p.next
            return

        # 연결 리스트 노드 삭제
        prev = p
        while p:
            if p.key == key:
                prev.next = p.next
                return
            prev, p = p, p.next
=> 앞서 파이썬의 딕셔너리는 오픈 어드레싱을 사용한다고 했지만 여기서는 개별 체이닝 방식으로 구현해본다.
여기서는 초기화 __init__(), 삽입 put(), 조회 get(), 삭제 remove()의 총 4가지 기능이 있으며, 편의상 키와 값은 모두 int로 한다.
이외에도 키, 값을 보관하고 연결 리스트로 처리할 별도의 객체를 구현해야 한다. 여기서는 ListNode라는 이름의 클래스를 정의한다.
편리하게 구현하기 위해 존재하지 않는 키를 조회할 경우 자동으로 디폴트를 생성해주는 collections.defaultdict를 사용했다.
모듈로(Modulo, mod) 연산을 통한 해싱은 해시 테이블의 가장 기본적인 해싱 방식이기도 하다.

ListNode() 클래스의 생성 함수 __init__()을 살펴보면, key=None, value=None으로 초깃값을 정헸다.
이 부분은 defaultdict의 특징이며 매우 편리하게 사용할 수 있는 반면, 이처럼 자동으로 처리해주는 부분들이 있으므로 자칫 잘못하면 버그를 유발할 수 있다.


문제29. 보석과 돌
J는 보석이며, S는 갖고 있는 돌이다. S에는 보석이 몇 개나 있을까? 대소문자는 구분한다.

예제1)
입력: J = "aA", S = "aAAbbbb"
출력: 3

풀이1) 해시 테이블을 이용한 풀이
class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
        freqs = {}
        count = 0

        # 돌(S)의 빈도 수 계산
        for char in S:
            if char not in freqs:
                freqs[char] = 1
            else:
                freqs[char] += 1

        # 보석(J)의 빈도 수 합산
        for char in J:
            if char in freqs:
                count += freqs[char]

        return count
=> 먼저 freqs라는 해시 테이블을 선언한다. 그리고 돌의 모음인 S를 문자 단위로 하나씩 분리해 반복한다.
만약 처음 등장한 문자라면 1을 선언하고, 기존에 있던 문자라면 1을 더한다.
딕셔너리에 각 문자별 빈도 수가 저장된다.

풀이2) defaultdict를 이용한 비교 생략
import collections


class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
        freqs = collections.defaultdict(int)
        count = 0

        # 비교 없이 돌(S) 빈도 수 계산
        for char in S:
            freqs[char] += 1

        # 비교 없이 보석(J) 빈도 수 합산
        for char in J:
            count += freqs[char]

        return count
=> defaultdict는 존재하지 않는 키에 대해 디폴트를 리턴해주므로 코드 줄 수를 훨씬 더 줄일 수 있다.
키가 존재하는지 여부를 매번 판별할 필요가 없기 때문에 이처럼 바로 계산할 수 있고, 코드 수도 많이 줄어들어 깔끔해졌다.

풀이3) Counter로 계산 생략
import collections

class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
        freqs = collections.Counter(S)  # 돌(S) 빈도 수 계산
        count = 0

        # 비교 없이 보석(J) 빈도 수 합산
        for char in J:
            count += freqs[char]

        return count
=> Counter를 사용하면 코드를 더욱 짧게 줄일 수 있다.
각 개수를 계산하는 부분까지 자동으로 처리할 수 있다.
아울러 Counter는 존재하지 않는 키의 경우 KeyError를 발생하는 게 아니라 0을 출력해주기 때문에, defaultdict와 마찬가지로 에러에 대한 예외 처리를 할 필요가 업삳.
단순히 J에 포함된 문자으 개수를 계산하기만 하면 된다.

풀이4) 파이썬 다운 방식
class Solution:
    def numJewelsInStones(self, J: str, S: str) -> int:
        return sum(s in J for s in S)
=> 해시 테이블과는 관련이 없지만, 이 문제는 파이썬다운 방식으로 단 한 줄로 계산할 수 있다.


문제30. 중복 문자 없는 가장 긴 부분 문자열
중복 문자가 없는 가장 긴 부분 문자열의 길이를 리턴하라.

예제1)
입력: "abcabcbb"
출력: 3

풀이1) 슬라이딩 윈도우와 투 포인터로 사이즈 조절
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        used = {}
        max_length = start = 0
        for index, char in enumerate(s):
            # 이미 등장했던 문자라면 `start` 위치 갱신
            if char in used and start <= used[char]:
                start = used[char] + 1
            else:  # 최대 부분 문자열 길이 갱신
                max_length = max(max_length, index - start + 1)

            # 현재 문자의 위치 삽입
            used[char] = index

        return max_length
=> 슬라이딩 윈도우로 한 칸씩 우측으로 이동하면서 윈도우 내에 모든 문자가 중복이 없도록 투 포인터로 윈도우 사이즈를 조절하면서 풀이한다.


문제31. 상위 K 빈도 요소
상위 K번 이상 등장하는 요소를 추출하라.

예제1)
입력: nums = [1,1,1,2,2,3], k = 2
출력: [1,2]

풀이1) Counter를 이용한 음수 순 추출
import collections
import heapq
from typing import List

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        freqs = collections.Counter(nums)
        freqs_heap = []
        # 힙에 음수로 삽입
        for f in freqs:
            heapq.heappush(freqs_heap, (-freqs[f], f))

        topk = list()
        # k번 만큼 추출, 민 힙 이므로 가장 작은 음수 순으로 추출
        for _ in range(k):
            topk.append(heapq.heappop(freqs_heap)[1])

        return topk
=>요소의 값을 키로 하는 해시 테이블을 만들고 여기에 빈도 수를 저장한 다음, 우선순위 큐를 이용해 상위 k번만큼 추출하면 k번 이상 등장하는 요소를 손쉽게 추출할 수 있다.
우선순위 큐는 힙을 활용하는 heapq 모듈을 사용한다.
여기서는 빈도 수르르 키로하고, freqs의 키를 값으로 했다. 즉 키/값을 바꿔서 힙에 추가했다.
힙은 순서대로 정렬되기 때문에 이를 위해 빈도 수를 키로 한 것이다 또한 값을 음수로 저장했다.
파이썬 모듈은 최소 힙만지원하기 때문이다. 모듈 차원에서는 최대 힙도 지원하긴 하지만 메소드가 프로텍티드 멤버로 선언되어 있고 함수명이 밑줄(_)로 시작하기 때문에
직접 호출하는 게 권장하는 방법은 아니다. 따라서 여기서는 최소 힙을 그대로 사용하되 음수로 변환해 가장 빈도 수가 높은 값이 가장 큰 음수가 되게 한다.
이렇게 하면 최소 힙으로도 빈도 수가 가장 높았던 값을 추출할 수 있다. 마지막으로 다음과 같이 heappop()으로 k번만큼 값을 추출하면 결과를 얻을 수 있다.

풀이2) 파이썬다운 방식
import collections


class Solution:
    def topKFrequent(self, nums, k):
        return list(zip(*collections.Counter(nums).most_common(k)))[0]
=> 상위 k번만큼의 요소를 추출하기 위해, 힙에 넣고 뺴는 작업들을 자동으로 할 수는 없을까?
이 문제도 Counter를 이용하여 파이썬다운 방식으로 풀이할 수 있다.
Counter는 most_common()이라는 빈도 수가 높은 순서대로 아이템을 추출하는 기능을 제공한다.

* zip() 함수
zip() 함수는 2개 이상의 시퀀스를 짧은 길이를 기준으로 일대일 대응하는 새로운 튜플 시퀀스를 만드는 역할을 한다.
파이썬 2에서는 zip()의 결과가 바로 리스트가 된다. 하지만 파이썬 3+에서는 제너레이터를 리턴한다.
제너레이터를 리턴하는 게 어떤 장점이 있는지는 3장의 81페이지에서 이미 충분히 설명한 바 있다.
제너레이터에서 실제값을 추출하기 위해서는 다음과 같이 list()로 한 번 더 묶어주면 된다.
아울러 zip()의 결과 자체는 리스트 시퀀스가 아닌 튜플 시퀀스를 만들기 때문에, 값을 변경하는 게 불가능하다. 불변 객체이다.

* 아스테리스크(*)
어떻게 zip()과 같은 함수들은 다양한 개수의 인수값을 전달받을 수 있을까?
여기에는 아스테리스크(Asterisk) 혹은 흔히 별표라고 부르는 *를 활용한다.
C의 포인터와 혼동될 수 있지만 파이선에는 포인터가 존재하지 않는다. 게다가 생긴 건 비슷하지만 전혀 다른 동작을 수행한다.
파이썬에서 *는 언팩(Unpack)이다. 시퀀스 언패킹 연산자로 말 그대로 시퀀스를 풀어 헤치는 연산자를 뜻하며, 주로 튜플이나 리스트를 언패킹하는 데 사용한다.
언패킹한 값만 별도로 출력할 수가 없기 때문에 디버깅이 어렵다.

만약 fruits = ['lemon', 'pear', 'watermelon', 'tomato'] 리스트에서 각 요소의 값만 출력하고 싶다면
print(*fruits)를 통해 각 요소의 값만 매우 간편하게 출력할 수 있다.

이외에도 *는 활용도가 많다. 언패킹뿐만 아니라 함수의 파라미터가 되었을 떄는 반대로 패킹(Packing)도 가능하다. 이는 파이썬 3+에서 print() 함수의 기본 동작 원리이기도 하다.
변수 할당 또한 이렇게 *로 묶어서 처리할 수 있다. 일반적인 변수는 값을 하나만 취하지만 *로 처리하게 되면 나머지 모든 값을 취하게 된다.
마지막으로 하나가 아닌 2개를 쓰는 경우도 있다. **인데 마찬가지로 C의 더블 포인터와 동일하게 생겼지만 전혀 다른 동작을 수행한다.
파이썬에서 * 1개는 튜플 또는 리스트 등의 시퀀스 언패킹이고, ** 2개는 다음과 같이 키/값 페어를 언패킹하는 데 사용된다.







