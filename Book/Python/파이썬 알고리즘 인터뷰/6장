6장 문자열 조작

문자열 조작이란 문자열을 변경하거나 분리하는 등의 여러 과정을 말한다.

문제1. 유효한 팰린드롬
주어진 문자열이 팰린드롬(앞뒤가 똑같은 단어나 문장으로, 뒤집어도 같은 말이 되는 단어 또는 문장)인지 확인하라. 대소문자를 구분하지 않으며, 영문자와 숫자만을 대상으로 한다.

예제1)
입력: "A man, a plan, a canal: Panama"
출력: "true"

풀이1) 리스트로 변환
def isPalindrome(self, s: str) -> bool:
    strs = []
    for char in s:
        if char.isalnum():
            strs.append(char.lower())

    while len(strs) > 1:
        if strs.pop(0) != strs.pop():
            return False
    return True
=> 문자열의 문자들을 isalnum()을 이용해 영문자와 숫자인 문자만 판별하여 새로운 리스트를 만들었다.
pop() 함수를 통해 리스트의 맨 앞과 맨 뒤의 값을 매칭해 나가면서 결과를 도출한다.

풀이2) 데크 자료형을 이용한 최적화 (Deque를 명시적으로 선언하면 속도를 개선할 수 있다)
def isPalindrome(self, s: str) -> bool:
    strs: Deque = collections.deque()

    for char in s:
        if char.isalnum():
            strs.append(char.lower())

    while len(strs) > 1:
        if sttrs.popleft() != strs.pop():
            return False

    return True
=> 자료형을 Deque로 변경하는 것만으로도 성능이 5배 가까이 개선되었다.
리스트의 pop(0)은 O(n)인 데 반해, Deque의 popleft()는 O(1)이기 때문이며, 각각 n번씩 반복하면 리스트 구현은 O(n²), 데크 구현은 O(n)으로 성능 차이가 크다.

풀이 3) 슬라이싱 사용
def isPalindrome(self, s: str) -> bool:
    s = s.lower()
    s = re.sub('[^a-z0-9]'. '', s)

    return s = s[::-1]
=> 여기서는 별달리 알고리즘이라 부를 만한 게 없다. 정규식으로 불필요한 문자를 필터링하고, 문자열을 조작할 수 있는 파이썬의 슬라이싱(Slicing)을 사용했다.
앞서 풀이에서는 isalnum()으로 모든 문자를 일일이 점검했지만 여기서는 문자열 전체를 한 번에 영숫자만 걸러내도록 정규식으로 처리했다.
또한 파이썬은 문자열을 배열이나 리스트처럼 자유롭게 슬라이싱할 수 있는 좋은 기능을 제공하며, [::-1]을 이용하면 뒤집을 수 있다. (코드가 훨씬 더 줆어듦은 물론, 내부적으로 C로 빠르게 구현되어 있어 훨씬 더 좋은 속도를 기대할 수 있다.)
이 경우, 앞선 풀이2에 비해 약 2배 정도 속도가 개선되었다.

** 문자열 슬라이싱
파이썬에서는 문자열 슬라이싱이라는 매우 빠르고 편리한 기능을 제공한다.
위치를 지정하면 해당 위치의 배열 포인터를 얻게 되며 이를 통해 연결된 객체를 찾아 실제 값을 찾아내는데, 이 과정은 매우 빠르게 진행되므로 문자열을 조작할 때는 항상 슬라이싱을 우선으로 사용하는 편이 속도 개선에 유리하다.


문제2. 문자열 뒤집기
문자열을 뒤집는 함수를 작성하라. 입력값은 문자 배열이며, 리턴 없이 리스트 내부를 직접 조작하라.

예제1)
입력: ["h","e","l","l","o"]
출력: ["o","l","l","e","h"]

풀이1) 투 포인터를 이용한 스왑
def reverseString(self, s: List[str]) -> None:
    left, right = 0, len(s) -1
    while left < right:
        s[left], s[right] = s[right], s[left]
        left += 1
        right -= 1
=> 두개의 포인터를 이용해 범위를 조정해가며 풀이하는 방식.
점점 더 범위를 좁혀 가며 스왑하는 형태로 풀이할 수 있다.

풀이2) 파이썬다운 방식
def reverseString(self, s: List[str]) -> None:
    s.reverse()
=> reverse()는 리스트에만 제공된다.
만약 입력값이 문자열이라면 앞서 살펴본 바와 같이 문자열 슬라이싱을 사용할 수 있다. 슬라이싱은 리스트에도 사용할 수 있으며 성능 또한 매우 좋다.
s = s[::-1] 풀이는 리트 코드에서는 오류가 발생한다. 원래는 정상적으로 처리되어야 하지만 이 문제는 공간 복잡도를 O(1)로 제한하다 보니 변수 할당을 처리하는 데 다소 제약이 있다.
s[:] = s[::-1]와 같이 트릭을 사용하면 잘 동작한다.


문제3. 로그 파일 재정렬
로그를 재정렬하라. 기준은 다음과 같다.
1. 로그의 가장 앞 부분은 식별자다.
2. 문자로 구성된 로그가 숫자 로그보다 앞에 온다.
3. 식별자는 순서에 영향을 끼치지 않지만, 문자가 동일한 경우 식별자 순으로 한다.
4. 숫자 로그는 입력 순서대로 한다.

예제1)
입력: logs = ["dig1 8 1 5 1", "let1 art can", "dig2 3 6", "let2 own kit dig", "let3 art zero"]
출력: ["let1 art can", "let3 art zero", "let2 own kit dig", "dig1 8 1 5 1", "dig2 3 6"]

풀이1) 람다와 + 연산자를 이용
def reorderLogFiles(self, logs: List[str]) -> List[str]:
    letters, digits = [], []
    for log in logs:
        if log.split()[1].isdigit():
            digits.append(log)
        else:
            letters.append(log)
    letters.sort(key=lambda x: (x.split()[1:], x.split()[0]))
    return letters + digits
=> isdigit()을 이용하여 숫자 여부인지를 판별해 구분해본다.
숫자로 변환 가능한 로그는 digits에, 그렇지 않은 경우 문자 로그는 letters에 추가된다.
이제 문자 로그는 letters에 모두 모였으므로 lambda 함수를 이용하여 다음과 같이 이를 제대로 정렬하기만 하면 된다.
여기서는 식별자를 제외한 문자열 [1:]을 키로 하여 정렬하며, 동일한 경우 후순위로 식별자[0]를 지정해 정렬되도록 람다 표현식을 이용해 정렬했다.

** 람다 표현식
람다 표현식이란 식별자 없이 실행 가능한 함수를 말하며, 함수 선언 없이도 하나의 식으로 함수를 단순하게 표현할 수 있다.
그러나 이 책에서는 람다 표현식보다 훨씬 더 간결하고 가독성이 높은 리스트 컴프리헨션을 주로 사용할 예정이다. 그러나 이 문제처럼 꼭 필요한 경우에는 람다로 풀이하는 게 더 편하다.
람다 표현식을 사용하면 별도의 함수를 선언하지 않고도 간단한 함수를 선언한 것처럼 쉽게 처리할 수 있지만 람다 표현식은 코드가 길어지고 map이나 filter와 같이 함께 섞어서 사용하기 시작하면 가독성이 매우 떨어질 수 있으므로 주의가 필요하다.


문제4. 가장 흔한 단어
금지된 단어를 제외한 가장 흔하게 등장하는 단어를 출력하라. 대소문자 구분을 하지 않으며, 구두점(마침표, 쉼표 등) 또한 무시한다.

예제1)
입력: paragraph = "Bob hit a ball, the hit BALL flew fat after it was hit."
banned = ["hit"]
출력: "ball"

풀이1) 리스트 컴프리헨션, Counter 객체 사용
def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
    words = [word for word in re.sub(r'[^\w]', ' ', paragraph)
        .lower().split()
            if word not in banned]

    counts = collections.Counter(words)
    return counts.most_common(1)[0][0]
=> 입력값에는 대소문자가 섞여 있으며 쉼표 등 구두점이 존재한다. 따라서 데이터 클렌징이라 부르는 입력값에 대한 전처리 작업이 필요하다.
정규식에서 \w는 단어 문자(word character)를 뜻하며, ^은 not을 의미한다. 따라서 위 정규식은 단어 문자가 아닌 모든 문자를 공백으로 치환하는 역할을 한다.
아울러, 리스트 컴프리헨션의 조건절에는 banned에 포함되지 않은 단어만을 대상으로 한다. 따라서 words에는 소문자, 구두점을 제외하고 banned를 제외한 단어 목록이 저장된다.
words에서 가장 흔하게 등장하는 단어의 첫 번째 값을 most_common(q)으로 추출한다.
문제의 입력값에서는 [('ball', 2)]가 되며, 이 값의 [0][0]을 추출해서 최종적으로 첫 번째 인덱스의 키를 추출하게 된다.


문제5. 그룹 애너그램
문자열 배열을 받아 애너그램(일종의 언어유희로 문자를 재배열하여 다른 뜻을 가진 단어로 바꾸는 것을 말함) 단위로 그룹핑하라.

예제1)
입력: ["eat", "tea", "tan", "ate", "nat", "bat"]
출력:
[
    ["ate", "eat", "tea"],
    ["nat","tan"],
    ["bat"]
]

풀이1) 정렬하여 딕셔너리에 추가
def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
    anagrams = collections.defaultdict(list)

    for word in strs:
        anagrams[''.join(sorted(word))].append(word)
    return list(anagrams.values())
=> 애너그램을 판단하는 가장 간단한 방법은 정렬하여 비교하는 것이다. 애너그램 관계인 단어들을 정렬하면, 서로 같은 값을 갖게 되기 때문이다.
sorted()는 문자열도 잘 정렬하며 결과를 리스트 형태로 리턴하는데, 이를 다시 키로 사용하기 위해 join()으로 합쳐 이 값을 키로 하는 딕셔너리로 구성한다.
애너그램끼리는 같은 키를 갖게 되고 따라서 여기에 append() 하는 형태가 된다. 이처럼 정렬한 값을 키로 하여 딕셔너리에 추가한다.
만약 존재하지 않는 키를 삽입하려 할 경우 KeyError가 발새하므로, 에러가 나지 않도록 다음과 같이 항상 디폴트를 생성해주는 defaultdict()로 선언하며, 매번 키 존재 여부를 체크하지 않고 비교 구문을 생략해 간결하게 구성한다.

** 여러가지 정렬 방법
sorted() 함수는 리스트를 잘 정렬하며, 숫자뿐만 아니라 문자도 정렬이 가능하다.
문자열을 정렬한 후 다시 문자열로 결합하려면 "".join(sorted(b))와 같이 이용하면 된다.
파이썬은 sorted()라는 별도 함수 외에도 리스트 자료형은 sort() 메소드를 함께 제공하며, 리스트 자체를 정렬할 수 있다.
이를 제자리 정렬이라고 부르는ㄷ[, 일반적으로 제자리 정렬 알고리즘은 입력을 출력으로 덮어 쓰기 때문에 별도의 추가 공간이 필요하지 않으며 리턴값이 없다.
따라서 정렬 결과를 별도로 리턴하는 sorted()와 다르므로 주의가 필요하다.
sorted()는 또한 key= 옵션을 지정해 정렬을 위한 키 또는 함수를 별도로 지정할 수 있다.

** 정렬 알고리즘과 팀소트
정렬 알고리즘 중 가장 인기 있는 알고리즘은 존 폰 노이만이 설계한 병합 정렬이다.
대부분은 퀵 정렬이 더 빠르지만 데이터에 따라 편차가 큰 반면, 병합 정렬은 일정하게 O(n log n)의 안정적인 성능을 보이며, 무엇보다 안정 정렬이라는 점에서 많이 선호된다.
파이썬의 sorted()는 팀소트(Timsort) 알고리즘을 사용한다.
팀소트는 '실제 데이터는 대부분 이미 정렬되어 있을 것이다'라고 가정하고 실제 데이터에서 고성능을 낼 수 있도록 설계한 알고리즘이다.
팀소트는 개별적인 단일 알고리즘이 아니라 삽입 정렬과 병합 정렬을 휴리스틱하게 적절히 조합해 사용하는 정렬 알고리즘이다.
대부분의 경우 정렬이 필요할 때는 파이썬의 정렬 함수를 사용하는 편이 가장 빠르다. 그 이유는 실제 데이터에 적합한 팀소트를 사용하면서도, 파이썬의 내장 함수로서 저수준의 언어를 이용해 매우 신중하게 작성되었기 때문이다.
이론적으로 어떠한 정렬 알고리즘도 한 번 이상 비교하게 되면 Ω(n log n)보다 빨라질 수 없다. 하지만 팀소트는 이미 정렬되어 있는 경우 비교를 건너뛰기 때문에 Ω(n)까지 가능하다.


문제6. 가장 긴 팰리드롬 부분 문자열
가장 긴 팰리드롬 부분 문자열을 출력하라

예제1)
입력: "babad"
출력: "bab"

풀이1) 중앙을 중심으로 확장하는 풀이
def longestPalindrome(self, s: str) -> str:
    def expand(left: int, right: int) -> str:
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
            return s[left + 1:right]

    if len(s) < 2 or s == s[::-1]:
        return s

    result = ''
    for i in range(len(s) - 1):
        result = max(result,
                        expand(i, i+1),
                        expand(i, i+2),
                        key=len)
    return result
=> '최장 공통 부분 문자열' 문제와 같이 다이나믹 프로그래밍으로 풀 수 있는 전형적인 문제이지만 이 문제의 경우, 다이나믹 프로그래밍을 이용한 풀이는 직관적으로 이해가 어렵고 실행 속도가 늦다.
따라서 여기서는 좀 더 직관적이면서도 훨씬 더 성능이 좋은, 투 포인터가 중앙을 중심으로 확장하는 형태로 풀이를 한다.
방식은 간단하다. 2,3칸으로 구성된 투 포인터가 슬라이딩 윈도우처럼 계속 앞으로 전진해 나간다. 이때 윈도우에 들어온 문자열이 팰린드롬인 경우 그 자리에 멈추고 투 포인터가 점점 확장하는 식이다.
먼저 예외처리를 해야 한다. 특히 파이썬의 문자열 슬라이싱은 앞서 살펴본 바와 같이 매우 빠르기 때문에 필터링하는 것만으로도 전체적인 풀이 속도 향상에 매우 큰 도움이 된다.
expand()로 정의한 중첩 함수에서 홀수, 짝수 2개의 투 포인터가 팰린드롬 여부를 판별하면서 슬라이딩 윈도우처럼 계속 우측으로 이동한다.
이렇게 판별한 최댓값이 최종 결과가 된다.

** 유니코드와 UTF-8
초기에 문자를 표현하던 대표적인 방식은 ASCII 인코딩 방식으로, 1 바이트에 모든 문자를 표현했다.
게다가 1 비트는 체크섬(Checksum)으로 제외하여 7비트, 즉 128 글자로 문자를 표현했다.
그러다 보니 한글이나 한자 같은 문자는 2개 이상의 특수 문자를 합쳐서 표현하곤 했는데, 당연히 이런 방식은 비정상적이며, 경우에 따라서는 깨지거나 제대로 표현되지 않는 경우가 잦았다.
이런 문제를 해결하기 위해 2~4 바이트의 공간에 여유 있게 문자를 할당하고자 등장한 방식이 바로 유니코드다.
그러나 유니코드 자체는 1 바이트로 표현이 가능한 영문자도 2바이트 이상의 공간을 사용하기 때문에 이를 그대로 사용하면 메모리 낭비가 심하다.
따라서 이를 가변 길이 문자 인코딩 방식으로 효율적으로 인코딩하는 대표적인 방식이 바로 우리가 잘 아는 UTF-8이다.
파이썬이 버전 3으로 넘어오면서 가장 큰 변화 중 하나는 바로 문자열의 처리 방식이다.
파이썬2 이전에는 한글을 비롯한 특수문자들이 모두 별도로 인코딩되는 구조라서, 콘솔에서 원래 값을 제대로 출력하기가 쉽지 않았다.
그러나 파이썬 3에 이르러서는 문자열은 모두 유니코드 기반으로 전환됐고 덕분에 많은 부분이 개선되어 파이썬3부터는 다국어를 출력하는 데 아무런 불편함이 없다.

가변 인코딩 방식, UTF-8은 유니코드를 어떤 방식으로 인코딩할까?
UTF-8 바이트 순서의 이진 포맷은 매우 간단하면서도 직관적이다. 시작 비트를 살펴보면 문자의 전체 바이트를 결정할 수 있다.
여기서 중요한 점은 유니코드 값에 따라 가변적으로 바이트를 결정하여 불필요한 공간 낭비를 절약할 수 있다는 점이다. 값이 127 이하라면 기존 ASCII 문자를 사용하여 1 바이트에 표현 가능하다. 이로써 불필요한 메모리 낭비를 절약할 수 있다.

앞써, 파이썬 3버전부터 유니코드로 모든 문자열을 표현한다고 했지만 사실 파이썬에서는 내부적으로 UTF-8 인코딩을 사용하지는 않는다.
이렇게 효율적인 인코딩 방식임에도 사용하지 않는 이유는 인덱스를 통해 개별 문자에 접근하기가 어렵기 때문이다.
파이썬에서는 문자열 슬라이싱을 비롯해 원하는 문자에 인덱스로 접근할 수 있는 다양한 방식을 제공하는데, 만약 문자열을 UTF-8으로 인코딩해준다면 각 문자마다 바이트 길이가 달라지게 되므로, 전체 문자열을 스캔하지 ㅇ낳는 한 원하는 인덱스에 빠르게 접근할 수 없다.
따라서 고정 길이 인코딩 방식이 필요하며, 파이썬은 문자열 단위로 다른 고정 길이 인코딩 방식을 적용해 이 문제를 해결한다.
각 문자열에 포함된 문자 범위에 따라 Latin-1, UCS-2, UCS-4 등 서로 다른 고정 인코딩 방식을 택함으로써, 내부적으로 파이썬은 문자열 슬라이싱을 포함한 원하는 인덱스에 빠르게 접근할 수 있게 하는 방식을 택하고 있다.



<추가 복습 포인트!>
isalpha(): 문자열이 영어 혹은 한글로 되어있으면 참 리턴, 아니면 거짓 리턴.
isalnum(): 문자열이 영어, 한글 혹은 숫자로 되어있으면 참 리턴, 아니면 거짓 리턴.

* isdecimal(), isdigit(), isnumeric()의 차이:
3²에서 ²는 특수문자이지만 isdigit() 함수와 isnumeric() 함수로는 True가 반환된다.
하지만 isdecimal() 함수로는 False가 반환된다.

isdigit() 함수는 단일 글자가 '숫자' 모양으로 생겼으면 무조건 True를 반환하는 함수. 즉, 숫자처럼 생긴 '모든 글자'를 숫자로 친다.
그에 비해 isdecimal() 함수는 주어진 문자열이 int형으로 변환이 가능한지 알아내는 함수이기 때문에 특수문자 중 숫자모양을 숫자로 치지않는다.
isnumeric() 함수는 숫자값 표현에 해당하는 문자열까지 인정한다. 제곱근 및 분수, 거듭제곱 특수문자도 isnumeric() 함수는 True를 반환하는 것을 알 수 있다.
즉, isdigit() > isnumeric() > isdecimal() 순서대로 유연하게 숫자로 인식함.
출처: https://it-neicebee.tistory.com/43?category=890500 [IT's Portfolio:티스토리]

* sort()와 sorted()의 차이
sorted()는 새로운 정렬된 목록을 반환하며, 원래 목록은 영향을 받지 않습니다.
list.sort()은 list을 그 자리에서 정렬하고 목록 인덱스를 변경하고 None을 반환합니다.(모든 내부 작업은 동일).
sorted()은 list뿐만 아니라 반복 가능한 모든 작업에 적용할 수 있습니다.
문자열, 튜플, 딕셔너리, 제너레이터 등 모든 요소가 포함된 반복 가능한 객체를 정렬하여 반환합니다.
따라서 list를 변경하려면 list.sort()를 사용하고, 새로운 정렬된 객체를 원하면 sorted()를 사용하면 됩니다.
list의 경우에 list.sort()는 복사본을 만들 필요가 없으므로 sorted()보다 빠릅니다. 다른 이터레이터의 경우 선택의 여지가 없습니다. (sorted만 사용할 수 있기 때문)
출처: https://velog.io/@sparkbosing/Python-sort%EC%99%80-sorted-%EC%B0%A8%EC%9D%B4