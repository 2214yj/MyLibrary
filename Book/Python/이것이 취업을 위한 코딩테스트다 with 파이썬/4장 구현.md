### 4장 구현
__구현이란 '머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정'이다.__  
어떤 문제를 풀든 간에 소스코드를 작성하는 과정은 필수이므로 구현 문제 유형은 모든 범위의 코딩 테스트 문제 유형을 포함하는 개념이다.  
구현 유형의 문제는 프로그래밍 언어 문법에 능숙하고 코드 작성 속도가 빠른 사람에게 확실히 유리하다.  

이 책에서는 완전 탐색, 시뮬레이션 유형을 모두 '구현' 유형으로 묶어서 다루고 있다.  
<b>완전 탐색</b>은 <b>모든 경우의 수를 주저 없이 다 계산하는 해결 방법</b>을 의미한다. 일반적으로 데이터의 개수가 100만 개 이하일 때 완전 탐색을 사용하면 적절하다.    
<b>시뮬레이션</b>은 <b>문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야 하는 문제 유형</b>을 의미한다.  

### 구현 시 고려해야 할 메모리 제약 사항
파이썬에서의 실수형 변수는 다른 언어와 마찬가지로 유효숫자에 따라서 연산 결과가 원하는 값이 나오지 않을 수 있다.  

파이썬에서 리스트를 이용할 때 코딩 테스트의 메모리 제한을 고려해야 한다. 수백만 개 이상의 데이터를 처리해야 하는 문제일 경우 메모리 제한을 염두에 두고 코딩해야 한다.
파이썬은 다른 언어에 비해서 구현상의 복잡함이 적은 편이지만 데이터 처리량이 많을 때는 꼭 메모리 제한을 고려해야 한다. 특히, 리스트의 크기가 1,000만 개 이상이라면 메모리 용량 제한으로 문제를 풀 수 없게 된는 경우도 있다.

### 채점 환경
파이썬은 다른 언어들에 비해 동작 속도가 느리다.  
시간 제한이 1초이고, 데이터 개수가 100만 개인 문제가 있다면 일반적으로 시간 복잡도 O(N log N) 이내의 알고리즘을 이용하여 문제를 풀어야 한다.  
따라서 알고리즘 문제를 풀 때는 시간 제한과 데이터의 개수를 먼저 확인한 뒤에 이 문제를 어느 정도의 시간 복잡도의 알고리즘으로 작성해야 풀 수 있을 것인지 예측할 수 있어야 한다.  

### 구현 문제에 접근하는 방법
자동 채점 방식을 이용하는 코딩 테스트 환경에서는 점점 Pypy3를 지원하는 곳이 늘고 있다.  
Pypy3는 파이썬3의 문법을 그대로 지원하며, 대부분 파이썬3보다 실행 속도가 더 빠르기 때문에 동일한 코드를 제출하더라도 python3보다 Pypy3에서 실행 시간을 줄일 수 있다.  
특히 반복문이 많을수록 속도차이가 극명하다.  

<br>

### 구현 유형 실전 문제 풀어보기
1. 상하좌우   
내 풀이)
```
    n = int(input())
    str = input().split()
    ox,oy = 1,1
    x,y = 1,1
    xl = [0,0,-1,1]
    yl = [-1,1,0,0]
    for i in str:
        ox,oy = x,y
        if i == 'L':
            x+=xl[0]
            y+=yl[0]
    
        elif i == 'R':
            x += xl[1]
            y += yl[1]
    
        elif i == 'U':
            x += xl[2]
            y += yl[2]
    
        else:
            x += xl[3]
            y += yl[3]
    
        if x < 1 or y <1 or x > n or y > n:
            x,y = ox,oy
    
    print(x,y)
```

<br>

2. 시각    
내 풀이)    
```
    n = int(input())
    count = 0
    for i in range(n+1):
        for j in range(60):
            for k in range(60):
                if '3' in f'{i}{j}{k}':
                    count += 1
    
    print(count)
```

<br>

3. 왕실의 나이트  
내 풀이)
```
    x,y = map(ord,input())
    x -= 96
    y -= 48
    nx = [2,2,-2,-2,1,1,-1,-1]
    ny = [1,-1,1,-1,2,-2,2,-2]
    count = 0
    for i in range(len(nx)):
        new_x,new_y = (x+nx[i]),(y+ny[i])
        if 0 < new_x < 9 and 0 < new_y < 9:
            count+=1
    print(count)
```

<br>

4. 게임 개발  
내 풀이)  
```
    n, m = map(int, input().split())
    x, y, z = map(int, input().split())
    arr, already = [], [(x,y)]
    for _ in range(n):
        arr.append(list(map(int, input().split())))
    pos = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    count, dir_count = 0, 0
    while True:
        z -= 1  # 현재 방향을 기준으로 왼쪽 방향으로 전환
        z %= len(pos)
        if arr[x + pos[z][0]][y + pos[z][1]] == 1:  # 바다라면
            dir_count += 1
        elif (x + pos[z][0], y + pos[z][1]) in already:
            dir_count += 1
        else:
            already.append((x + pos[z][0], y + pos[z][1]))
            # arr[x + pos[z][0]][y+pos[z][1]] = 1   # 가본 곳은 바다로 만든다
            x, y = x + pos[z][0], y + pos[z][1]  # 현재 위치를 업데이트
            count += 1
            dir_count = 0
    
        if dir_count == 4:  # 만약 모든 방향으로 갈 수 없다면
            if arr[x - pos[z][0]][y - pos[z][1]] == 1:  # 방향을 유지한 채로 한 칸 뒤로 간다. 이때 뒤에가 바다라면 종료
                break
            else:
                dir_count = 0
                x, y = x - pos[z][0], y - pos[z][1]
                count += 1
    
    print(count)
```


