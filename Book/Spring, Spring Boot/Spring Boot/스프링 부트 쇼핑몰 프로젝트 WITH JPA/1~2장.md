1장 개발 환경 구축    
1.1. 스프링 부트의 특징  
스프링 부트는 기존의 스프링 프레임워크보다 더 봄이 왔다는 뜻. 최소한의 설정으로 실행 버튼을 누르면 바로 애플리케이션이 실행되는 독립 실행 애플리케이션을 지향.  

< 스프링 부트의 특징 >  
1. 내장 서버를 이용해 별도의 설정 없이 독립 실행잉 가능한 스프링 애플리케이션.  
2. 톰캣, 제티 또는 언더토우와 같은 웹 애플리케이션 서버(WAS) 자체 내장.   
   디폴트 내장 서버로 톰캣을 사용하기 때문에 사용자는 웹 서버와 관련된 설정을 하지 않아도 됨. 또한 제티나 언더토우와 같은 내장 웹 서버를 사용하기 위해서는 pom, xml에 설정 값을 작성하는 것만으로 쉽게 변경 가능.  
3. 빌드 구성을 단순화하기 위한 'Spring Boot Starter' 의존성 제공.  
   스타터란 설정을 자동화해주는 모듈을 의미. 프로젝트에서 설정해야 하는 다양한 의존성을 사전에 미리 정의해서 제공.   
4. XML 설정 없이 단순 자바 수준의 설정 방식 제공.  
   XML에 설정을 작성할 필요 없이 자바 코드로 설정 가능. XML은 문법이 틀리거나 선언을 잘못하면 원인을 찾기 힘듦.  
5. JAR를 이용해 자바 옵션만으로 배포 가능.  
6. 애플리케이션의 모네터링과 관리를 위한 스프링 액추에이터 제공.  
<br><br>

1.4. 내플리케이션 실행하기  
스프링부트 프로젝트를 쉽게 만들기 위해서 Spring Initializr 사이트(https://start.spring.io)에서 템플릿을 다운로드해 임포트하여 사용.  
이니셜라이저는 애플리케이션에 필요한 의존성을 쉽게 추가할 수 있는 방법을 제공하며 많은 설정을 수행함.  
<br><br>  

1.4.2. 빌드 도구  
메이븐이란 자바 프로젝트의 빌드를 자동화해주는 빌드 툴. 개발 과정 중에 많은 라이브러리들이 필요.  
pom.xml 파일에 필요한 라이브러리를 적어주면 메이븐이 알아서 네트워크를 통해서 다운로드하고 경로까지 지정해줌.   
<br><br>  

1.4.3. 설정 파일(application.properties 또는 application.yml 파일)  
스프링 부트 애플리케이션 실행 시 사용하는 여러 가지 설정값(데이터베이스, port, debug, level 등)을 정의하는 파일.  
<br><br>

** 어노테이션이란?  
어노테이이션(Annotation)은 주석이라는 사전적 의미가 있음. 메타 데이터(데이터를 위한 데이터)라고도 불림.  
클래스나 메소드, 변수 등을 선언할 때 '@'을 붙여서 사용. 어노테이션은 컴파일러에게 저오를 알려주거나, 실행할 때 별도의 처리가 필요할 때 등 매우 다양한 용도로 사용 가능.  

@RestController  
=> @RestController는 Restful Web API를 좀 더 쉽게 만들기 위해 스프링 프레임워크 4.0에 도입된 기능. @Controller와 @ResponseBody를 합쳐 놓은 어노테이션.  
@Controller 어노테이션을 선언하면 해당 클래스를 요청을 처리하는 컨트롤러로 사용.  
@Responsebody 어놑테이션은 자바 객체를 HTTP 응답 본문의 객체로 변환해 클라이언트에게 전송함.  

@GetMapping  
=> @GetMapping 어노테이션을 이용해 클라이언트의 요청을 처리할 URL을 매핑함.  
<br><br>

1.5. Lombok 라이브러리
Lombok 라이브러리는 Getter, Setter, ToString 과 같은 반복적인 자바 코드를 컴파일 할 때 자동으로 생성해주는 라이브러리.   
Lombok 라이브러리를 사용하면 반복적인 소스코드를 제거할 수 있으므로 코드를 좀 더 깔끔하게 짤 수 있음.  

<Lombok 라이브러리의 주요 어노테이션들>   

|어노테이션                           | 설명                                                                                    |
|:---------------------------------|:--------------------------------------------------------------------------------------|
|@Getter/Setter                    | 코드를 커마일 할 때 속성들에 대한 Getter/Setter 메소드 생성.                                             |
|@ToString | toString() 메소드 생성.                                                                    |
|@ToString(exclude={"변수명"}) | 원하지 않는 속성을 제외한 toString() 메소드를 생성.                                                    |
|@NonNull | 해당 변수가 null 체크. NullPointerExcpetion 예외 발생.                                           |
|@EqualsAndHashCode | equals()와 hashCode() 메소드 생성.                                                          |
|@Builder | 빌더 패턴을 이용한 객체 생성.                                                                     |
|@NoArgsConstructor | 파라미터가 없는 기본 생성자 생성.                                                                   |
|@AllArgsConstructor | 모든 속성에 대한 생성자 생성.                                                                     |
|@RequiredArgsConstructor | log 변수 자동 생성.                                                                         |
|@Log | log 변수 자동 생성.                                                                         |
|@Value | 불변(immutable) 클래스 생성.                                                                 |
|@Data | @ToString, @EqualsAndHashCode, @Getter, @Setter, @RequiredArgsConstructor를 합친 어노테이션.  |




</br></br></br></br>
2장 Spring Data JPA  
JPA(Java Persistence API)는 자바 ORM 기술에 대한 API 표준. ORM이란 'Object Relational Mapping'의 약자로 객체와 관계형 데이터베이스를 매핑해주는 것을 말함.   
<br><br>
2.1.1. JPA란?  
객체와 관계형 데이터베이스의 패러다임 불일치가 가장 큰 문제점.     
자바는 객체 지향 패러다임으로 만들어졌고, 관계형 데이터베이스는 데이터를 정규화해서 잘 보관하는 것을 목표로 함.  
객체를 데이터베이스에 넣기 위해서는 SQL 문을 통해 변환해서 저장해야 하고, 데이터베이스에서 객체를 다시 꺼내오기 위해서는 복잡한 SQL문을 작성해야 함.  
결국, 객체를 단순히 게이터 전달 목적으로 사용할 뿐 객체지향적으로 프로그래밍을 할 수 없음. 이를 해결하기 위해 나온 기술이 ORM  

객체는 객체지향적으로, 데이터베이스는 데이터베이스 대로 설계. ORM은 중간에서 2개를 매핑하는 역할을 함.  
JPA는 위에서 설명한 ORM 기술의 표준 명세로 자바에서 제공하는 API.  
즉, JPA는 구현한 대표적인 구현체로 Hibernate, EclipseLink, DataNucleus, OpenJpa, TopLink 등이 있음.  
JPA 인터페이스를 구현한 가장 대표적인 오픈소스가 Hibernate이다.  
<br><br>  
<JPA 사용 시 장점>  
1. 특정 데이터베이스에 종속되지 않음.  
   JPA는 추상화한 데이터 접근 계층을 제공. 설정 파일에 어떤 데이터베이스를 사용하는지 알려주면 얼마든지 데이터베이스를 변경 가능.
2. 객체지향적 프로그래밍.  
   JPA를 사용하면 객체 지향적으로 설계 가능. 이를 통해 좀 더 직관적이고 비즈니스 로직에 집중할 수 있도록 도와줌.  
3. 생산성 향상.  

<JPA 사용 시 단점>  
1. 복잡한 쿼리 처리  
   복잡한 쿼리를 사용할 경우는 SQL 문을 사용하는 게 나을 수도 있음. JPA에서는 Native SQL을 통해 기존의 SQL 문을 사용할 수 있지만 그러면 특정 데이터베이스에 종속된다는 단점이 생김.  
   이를 보완하기 위해서 SQL과 유사한 기술인 JPQL을 지원함.  
2. 성능 저하 위험  
   객체 간의 매핑 설계를 잘못했을 때 성능 저하가 발생할 수 있으며 자동으로 생성되는 쿼리가 많기 때문에 개발자가 의도하지 않는 쿼리로 인해 성능이 저하됨.  
3. 학습 시간  
<br><br>

2.1.2. JPA 동작 방식  
- 엔티티: 엔티티란 데이터베이스 테이블에 대응하는 클래스라고 볼 수 있음.  
- 엔티티 매니저 팩토리: 엔티티 매니저 인스턴스를 관리하는 주체. 애플리케이션 실행 시 한 개만 만들어지며 사용자로부터 요청이 오면 엔티티 메니저 팩토리로부터 엔티티 메니저를 생성.  
- 앤티티 매니저: 엔티티 매니저란 영속성 컨텍스트에 접근하여 엔티티에 대한 데이터베이스 작업을 제공. 내부적으로 데이터베이스 커넥션을 사용해서 데이터베이스에 접근.  
  - find(): 영속성 컨텍스트에서 엔티티를 검색하고 영속성 컨텍스트에 없을 경우 데이터베이스에서 데이터를 찾아 영속성 컨텍스트에 저장.   
  - persist(): 엔티티를 영속성 컨텍스트에 저장.  
  - remove(): 엔티티 클래스를 영속성 컨텍스트에서 삭제.  
  - flush(): 영속성 컨텍스트에 저장된 내용을 데이터베이스에 반영.  

- 영속성 컨텍스트: 영속성 컨텐스트란 엔티티를 영구 저장하는 환경이라는 뜻. 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을 함. 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리.  
- 엔티티 생명 주기:
![img.png](https://user-images.githubusercontent.com/54930365/175473515-41a5b853-0de5-4eae-86d6-03b697d7ca92.png)  


<엔티티 생명주기의 세부 내용>  

   |생명주기| 내용                                                                                                     |
   |--------------------------------------------------------------------------------------------------------|-----|
   |비영속(new)| new 키워드를 통해 생성된 상태로 영속성 컨텍스트와 관련이 없는 상태                                                                |
   |영속(managed)| - 엔티티가 영속성 컨텍스트에 저장된 상태로 영속성 컨텍스트에 의해 관리되는 상태.</br>- 영속 상태에서 데이터베이스에 저장되지 않으며, 트랜젝션 커밋 시점에 데이터비에스에 반영. |
   |준영속 상태(detached)| 영속성 컨텍스트에 엔티티가 저장되었다가 분리된 상태                                                                           |


<br><br>
영속성 컨텍스트 사용 시 이점    
JPA는 애플리케이션과 데이터베이스 사이에 중간 계층인 영속성 컨텍스트를 사용.    
이렇게 중간 계층을 만들면 버퍼링, 캐싱 등을 할 수 있는 장점이 있음.    

- 1차 캐시: 영속성 컨텍스트에는 1차 캐시가 Map(KEY,VALUE) 형태로 저장됨.  
- 동일성 보장  
- 트랜젝션을 지원하는 쓰기 지연: 영속성 컨텍스트에는 쓰기 지연 SQL 저장소가 존재함. entity.persist()를 호출하면 1차 캐시에 저장되는 것과 동시에 쓰기 지연 SQL 저장소에 SQL 문이 저장됨. 이렇게 SQL을 쌓아두고 트랜젝션을 커밋하는 시점에 저장된 SQL 문들이 flush 되면서 데이터베이스에 반영됨.  
  이렇게 모아서 보내기 때문에 성능에서 이점을 볼 수 있음.
- 변경 감지: 스냅샷 비교를 통해 변경 내용을 감지하고 변경 내용이 있다면 데이터베이스에 커밋 시점에 변경 내용을 자동으로 반영.  


<br><br>
2.3. 상품 엔티티 설계하기
엔티티란 데이터베이스의 테이블에 대응하는 클래스라고 생각하면 됨. @Entity가 붙은 클래스는 JPA에서 관리하며 엔티티라고 함.   

<엔티티 매핑 관련 어노테이션>

|어노테이션| 설명                         |
|---|----------------------------|
|@Entity| 클래스를 엔티티로 선언               |
|@Table| 테이블의 기본키에 사용할 속성을 지정       |
|@Id| 테이블의 기본키에 사용할 속성을 지정       |
|@GeneratedValue| 키 값을 생성하는 전량 명시            |
|@Column| 필드와 칼럼 매핑. 다양한 조건 설정 가능.   |
|@Lob| BLOB, CLOB 타입 매핑(용어 설명 참조) |
|@CreationTimestamp| insert 시 시간 자동 저장          |
|@UpdateTimestamp| update 시 시간 자동 저장          |
|@Enumerated| enum 타입 매핑                 |
|@Tansient| 해당 필드 데이터베이스 매핑 무시         |
|@Temporal| 날짜 타입 매핑                   |
|@CreateDate| 엔티티가 생성되어 저장될 때 시간 자동 저장   |
|@LastModifiedDate| 조회한 엔티티의 값을 변경할 때 시간 자동 저장 |

<br><br>
2.4. Repository  
Spring Data JPA에서는 엔티티 매니저를 직접 이용해 코드를 작성하지 않아도 됨. 그 대신에 Data Access Object의 역할을 하는 Repository 인터페이스를 설계한 후 사용하는 것만으로 충분.
앞에서 보여준 엔티티 매니저 코드는 JPA가 엔티티를 어떻게 관리하는지 보여주기 위함.
Repository는 JpaRepository를 상속 받음. JpaRepository는 2개의 제네릭 타입을 사용. 첫 번째에는 엔티티 타입 클래스를 넣어주고, 두 번째는 기본키 타입을  넣어줌.
JpaRepository는 기본적인 CRUD 및 페이징 처리를 위한 메소드가 정의되어 있음.

<JPA에서 지원하는 메소드 예시>

| 메소드                             | 기능          |
|---------------------------------|-------------|
| \<S extends T \> save(S entity) | 엔티티 저장 및 수정 |
| void delete(T entity)           | 엔티티 삭제|
| count()                         | 엔티티 총 개수 반환|
| Iterable<T> findAll()           | 모든 엔티티 조회|

<br><br>
2.5. 쿼리메소드  
find 문: ```find + (엔티티 이름) + By + 변수 이름``` 
<br><br>

2.6. Spring DATA JPA @Query 어노테이션  
앞서 배운 쿼리메소드는 조건이 적은 간단한 쿼리를 처리할 때에는 유용하지만 복잡한 쿼리를 다루기에는 적합하지 않음.  
이를 보완하는 방법이 @Query 어노테이션을 이용하는 것!

Spring Data JPA에서 제고와는 @Query 어노테이션을 이용하면 SQL과 유사한 JPQL(Java Persistence Query Language)이라는 객체지향 쿼리 언어를 통해 복잡한 쿼리도 처리가 가능.  
JPQL은 엔티티 객체를 대상으로 쿼리를 수행하는 객체지향 쿼리.  
JPQL은 SQL을 추사ㅏㅇ화해서 사용하기 때문에 특정 데이터베이스 SQL에 의존하지 않음.즉, JPQL로 작성했자면 데이터베이스가 변경되어도 애플리케이션이 영향을 받지 않음.  

사용법: ```@Query("JPQL 문")```
기존의 데이터베이스에서 사용하던 쿼리를 그대로 사용할 경우, nativeQuery 속성을 true로 설정해주면 됨. 하지만 특정 데이터베이스에 종속되는 쿼리문을 사용하기 때문에 데이터베이스에 대해 독립적이라는 장점을 잃어버림.  
<br><br>

2.7. Spring DATA JPA Querydsl  
앞서 배운 @Query 어노테이션을 이용한 방법에도 단점이 있음. @Query 어노테이션 안에 JPQL 문법으로 문자열을 입력하기 때문에 잘못 입력하면 컴파일 시점에 에러를 발견할 수 없음.  
에러는 가능한 빨리 발견하는 것이 가장 좋으므로 이를 보완할 수 있는 방법이 바로 Querydsl!  

Querydsl은 JPQL을 코드로 작성할 수 있도록 도와주는 빌더 API. Querydsl은 소스코드로 SQL 문을 문자열이 아닌 코드로 작성하기 때문에 컴파일러의 도움을 받을 수 있음. 또한 동적으로 쿼리를 생성해줌.

<Querydsl 장점>
- 고정된 SQL문이 아닌 조건에 맞게 동적으로 쿼리를 생성할 수 있음.
- 비슷한 쿼리를 재사용할 수 있으며 제약 조건 조립 및 가독성을 향상시킬 수 있음.
- 문자열이 아닌 자바 소스코드로 작성하기 때문에 컴파일 시점에 오류를 발견할 수 있음.
- IDE의 도움을 받아서 자동 완성 기능을 이용할 수 있기 때문에 생산성을 향상시킬 수 있음.

























