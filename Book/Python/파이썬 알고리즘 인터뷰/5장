5장 리스트, 딕셔너리

리스트와 딕셔너리는 파이썬 코딩테스트에서 빈번하게 사용되는 자료형이다.

** 리스트
리스트는 순서대로 저장하는 시퀀스이자 변경 가능한 목록을 말한다.
입력 순서가 유지되며, 내부적으로는 동적 배열로 구현되어 있다. 파이썬의 리스트는 다양한 자료형을 단일 리스트에 관리할 수 있다.
파이썬 리스트의 가장 좋은 점은 매우 다양한 기능을 제공한다는 점이다. 스택과 큐에서 사용 가능한 모든 연산을 함께 제공한다.
그러나 큐 연산이자 요소를 삭제하는 연산인 pop(0)은 O(n)으로 리스트에서 큐의 연산을 사용할 떄는 주의가 필요하다.
이 경우, 데크(Deque) 같은 자료형으로 성능을 높일 수 있다.

<리스트의 주요 연산 시간 복잡도>
    (연산)         (시간 복잡도)        (설명)
    len(a)          O(1)            전체 요소의 개수를 리턴한다.
    a[i]            O(1)            인덱스 i의 요소를 가져온다.
    a[i:j]          O(k)            인덱스 i부터 j-1까지 슬라이스의 길이만큼인 k개의 요소를 가져온다.
                                    이 경우 객체 k개에 대한 조회가 필요하므로 O(k)이다.

    elem in a       O(n)            elem 요소가 존재하는지 확인한다. 처음부터 순차 탐색하므로 n만큼 시간이 소요된다.
    a.count(elem)   O(n)            elem 요소의 개수를 리턴한다.
    a.index(elem)   O(n)            elem 요소의 인덱스를 리턴한다.
    a.append(elem)  O(1)            리스트 마지막에 elem 요소를 추가한다.
    a.pop()         O(1)            리스트 마지막 요소를 추출한다. 스택의 연산이다.
    a.pop(0)        O(n)            리스트 첫번째 요소를 추출한다. 큐의 연산이다.
                                    이 경우 전체 복사가 필요하므로 O(n)이다. 큐의 연산을 주로 사용한다면 리스트보다는 O(1)에 가능한 데크(deque)를 권장한다.

    del a[i]        O(n)            i에 따라 다르다. 최악의 경우 O(n)이다.
    a.sort()        O(n log n)      정렬한다. Timsort를 사용하며, 최선의 경우 O(n)에도 실행될 수 있다.
    min(a), max(a)  O(n)            최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다.
    a.reverse()     O(n)            뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다.

* 리스트의 특징
파이썬의 리스트는 연속된 공간에 요소를 배치하는 배열의 장점과 다양한 타입을 연결해 배치하는 연결 리스트의 장점을 모두 취한 듯한 형태를 띠며, 실제로 리스트를 잘 사용하기만 해도 배열과 연결 리스트가 모두 필요 없을 정도로 강력하다.
CPython에서 리스트는 요소에 대한 포인터 목록을 갖고 있는 구조체로 선언되어 있다. 리스트에 요소를 추가하거나 조작하기 시작하면 ob_item의 사이즈를 조절해 나가는 형태로 구현되어 있다. 리스트는 이처럼 객체로 되어 있는 모든 자료형을 다음과 같이 포인터로 연결한다.
파이썬의 리스트는 연결 리스트에 대한 포인터 목록을 관리하고 있기 때문에 다양한 타입을 동시에 단일 리스트에서 관리하는 게 가능하다.
그러나 각 자료형의 크기는 저마다 서로 다르기 때문에 이들을 연속된 메모리 공간에 할당하는 것은 불가능하다. 결국 각각의 객체에 대한 참조로 구현할 수밖에 없다.
이에 따라, 값을 조회하기 위해 모든 포인터의 위치를 찾아가서 타입 코드를 화깅ㄴ하고 값을 일일이 살펴봐야 하는 등 추가적인 작업이 필요하기 때문에 속도 면에서도 훨씬 더 불리하다.
이처럼 파이썬은 강력한 기능을 위해 리스트와 객체에 대한 참조를 택했으며 이로 인해 부득이하게 속도를 희생한 측면이 있다.



** 딕셔너리
딕셔너리는 키/값 구조로 이뤄진 딕셔너리를 말한다. 파이썬 3.7 버전 이상에서는 입력 순서가 유지되며, 내부적으로는 해시 테이블로 구현되어 있다.
인덱스를 숫자로만 지정할 수 있는 리스트와 달리 딕셔너리는 문자를 포함해 다양한 타입(숫자, 문자, 집합 등 불변 객체)을 키로 사용할 수 있다.
해시 테이블은 다양한 타입을 키로 지원하면서도 입력과 조회 모두 O(1)에 가능하다. 물론 해시 테이블은 최악의 경우 O(n)이 될 수 있으나 분할 상환 분석에 따른 시간 복잡도는 O(1)이다.
파이썬 3.6 이하의 버전에서는 입력 순서가 유지되지 않아 collections.OrderedDict()라는 별도 자료형을 제공했다.

<딕셔너리의 주요 연산 시간 복잡도>
    (연산)            (시간 복잡도)            (설명)
    len(a)              O(1)            요소의 개수를 리턴하다.
    a[key]              O(1)            키를 조회하여 값을 리턴한다.
    a[key] = value      O(1)            키/값을 삽입한다.
    key in a            O(1)            딕셔너리에 키가 존재하는지 확인한다.

딕셔너리에 있는 키/값은 for 반복문으로도 조회가 가능하다. 딕셔너리의 items() 메소드를 사용하면 키와 값을 각각 꺼내올 수 있다.
ex) for k,v in a.items():
        print(k,v)

    =>  key1 value1
        key2 value2
        ...

딕셔너리의 키는 del로 삭제한다.
ex) del a['key1']

* 딕셔너리 모듈
defaultdict 객체: 존재하지 않는 키를 조회할 경우, 에러 메시지를 출력하는 대신 디폴트 값을 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다. 실제로는 collections.defaultdict 클래스를 갖는다.
ex) a = collection.defaultdict(int)

Counter 객체: 아이템에 대한 개수를 계산해 딕셔너리로 리턴. 키에는 아이템의 값이, 값에는 해당 아이템의 개수가 들어간 딕셔너리를 생성. 실제로 딕셔너리를 한 번 더 래핑한 collections.Counter 클래스를 갖는다.
             가장 빈도가 높은 요소를 추출하기 위해서는 most_common()을 사용하면 된다.
ex) b = collections.Counter(딕셔너리명)
    b.most_common(개수)

OrderedDict 객체: 입력 순서를 유지해준다. (파이썬 3.7 이상에서 딕셔너리는 내부적으로 인덱스를 이용하며 입력 순서가 유지되도록 개선됨)
                 또한 순서와 관련된 몇 가지 추가 메소드를 제공한다.





