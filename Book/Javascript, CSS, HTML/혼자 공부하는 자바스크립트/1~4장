
1장 자바스크립트의 활용

1. 웹 클라이언트 애플리케이션 개발
자바스크립트를 통해 웹 문서의 내용을 동적으로 바꾸거나 사용자의 마우스 클릭과 같은 이벤트 처리가 가능해짐.

기존의 웹 페이지보다 다양한 기능을 가진 웹 페이지를 웹 애플리케이션이라 부름.
웹 애플리케이션은 별도의 설치 없이 웹 브라우저만으로도 애플리케이션의 기능들을 사용할 수 있음. ex) 구글 문서

2. 웹 서버 애플리케이션 개발
2009년 Node.js의 등장으로 자바스크립트로도 웹 서버 애플리케이션을 개발할 수 있게 됨.

<Node.js의 장단점>
1. Node.js는 웹 서버 애플리케이션을 개발할 때 꼭 필요한 간단한 모듈만 제공.
따라서 데이터 처리와 예외 처리 등이 조금 복잡.
2. 하지만 Node.js는 빠름.
서버 구매 비용과 유지 비용이 다른 스크립트 언어와 프레임워크로 개발한 서버 애플리케이션에 비해 1/10배로 든다.
실제 링크드인에서 기존 루비로 개발한 서버 애플리케이션을 Node.js로 교채해 다시 개발한 결과, 서버는 1/10으로 줄었고 속도는 20배 더 빨라졌다고 발표.

3. 모바일 애플리케이션 개발
모든 스마트폰에는 내부에서 기본으로 인식할 수 있는 공통된 프로그래밍 언어가 있는데, 자바스크립트가 대표적.
페이스북에서는 자바스크립트로 네이티브 애플리케이션을 개발할 수 있는 리액트 네이티브를 만들어 공개함.
리액트 네이티브를 활용하면 자바스크립트만으로 모든 운영체제에서 빠르게 작동하는 네이티브 애플리케이션을 만들 수 있음.

4. 데스크톱 애플리케이션 개발
일렉트론을 이용해 데스크톱 애플리케이션 개발 가능

5. 데이터베이스 관리
MongoDB가 데이터베이스를 관리할 때 자바스크립트를 활용하는 대표적인 NoSQL(Not-Only-SQL) 데이터베이스.

번외. 모바일 애플리케이션의 종류
1. 네이티브 앱: 제조사가 추천하는 전용 프로그래밍 언어를 사숑해서 만들어진 애플리케이션.
2. 모바일 웹앱: 웹사이트를 애플리케이션으로 가싸기만 해서 보여줌. 아이폰 개발자와 안드로이드 개발자를 구분하지 않아도 되므로 비용적 부담이 줄어들지만 성능이 떨어지고 스마트폰이 가진 기능을 제대로 활용할 수 없음.
3. 하이브리드 앱: 모바일 웹앱의 단점을 보완하기 위해 중간에 스마트폰의 기능고 웹 페이지를 연결할 수 있는 층을 설치해서 웹사이트가 스마트폰의 기능을 활용할 수 있게 함.
4. 리액트 네이티브: 네이티브 앱처럼 만들어주는 엔진 또는 프레임워크 등장, 리액트 네이티브가 대표적인 예.



2장 자료와 변수

## 기본 자료형
Boolean, Number, String, Null, Undefined, Symbol 자료형을 제공.
다른 프로그래밍 언어들과 달리, 자바스크립트에서 '와 "은 동일

## 문자열에 적용할 수 있는 처리
1. 문자열 연결 연산: 문자열 + 문자열
2. 문자 선택 연산: 문자열[인덱스] -> 문자 하나
3. 문자열의 길이: 문자열.length -> 문자 개수


## 코드 실행기는 숫자로 시작하는 모든 것을 숫자로 인식. (숫자로 시작하는 식별자 만들 수 없기 때문)
실수 계산의 경우, 한정된 자원에 자료를 저장하기 때문에 오류 발생.
따라서, 정확한 계산을 요하는 경우에는 정수로 계산을 하고 후에 소수로 변환하는 방법을 사용하기도 함.
나머지 연산자(음수,양수 혼합 시 어떻게 될까? 프로그래밍 언어에 따라서 다름. 자바스크립트는 왼쪽 피연산자의 부호를 따라감)
5%2=1; 5%-2=1; --5%2=-1; -5%-2=-1;

## Bool을 만드는 법
1. true 또는 false를 그대로 입력
2. 비교 연산자를 사용.

## 논리연산자(||,&&)
||(또는), &&(그리고)
=> |와 &는 비트연산자.

비교연산자는 일반적으로 오른쪽으로만 입을 벌리게! 변수는 왼쪽에! 오도록 사용함.

typeof()
=>타입을 알려주는 단항 연산자
typeof 연산자는 결과로 string, number, boolean, undefined, function, object, ssymbol, bigint라는 8가지 자료형 중 하나를 출력.

템플릿 문자열
=> 백틱(``)사용. 내부에 ${표햔식} 사용 가능

## 비교연산자 '=='와 '==='
'=='의 경우, 예측하기 힘든 결과를 많이 도출함. 자료형이 달라도 변환 후의 값이 일치하면 true 리턴.
'==='의 경우, 값과 자료형이 같은지를 비교하는 연산.
ex)
0 == "0"  true
0 == ""    true
0 == "            "   true
0 == "        \n\n\n" true
=>'=='을 '==='로 바꾸면 false가 나옴.


## 상수만들기
const 식별자 = 자료

상수 관련 오류 세가지
=> 중복 오류, 상수는 중복 선언 불가능!
=> 상수를 만들 때, 값을 넣을 때 모두 'const 식별자 = 자료' 형태에서 어긋나면 오류 발생!
=> 초기화 오류, 상수는 값을 바꿀 수 없음!

## 변수 만들기
let 식별자 = 자료
=> 중복 선언 불가, 값 바꾸기 가능, 변수 만들때 자료를 지정해주지 않아도 됨.

## 상수와 변수의 상용 범위
상수 언제 사용? => 기본적! 무조건적으로 사용!
변수 언제 사용? => 변경이 필요한 경우에만

왜?
C, Java, C#, C++
=> 보통 변수만을 사용하고 고정되어야 하는 경우에만 상수 사용.
코드를 작성한 후에 복잡한 컴파일 과정을 거침, 그래서 어떠한 자료를 위한 공간을 어떻게 저장하면 효율적인지 모두 생각을 하므로 개발자가 따로 상수와 변수를 신경쓰지 않아도 내부적으로 완벽하게 가장 빠른 처리로 구성해줌.
컴파일러가 똑똑해서 내부적으로 알아서 잘 해줌. 개발자가 신경 안써도 됨.

루비, 파이썬, 루아, 자바스크립트
=> 기본적으로 인터프리터 언어(코드 실행기가 코드 전체를 보고 분석을 한 뒤에 실행하지 않고 한줄 한줄 볼 때마다 실행하는 언어)
이 역시 컴파일을 통해 최적화가 가능하지만 위의 고전적인 프로그래밍 언어들에 비해 최적화가조금 힘듦

결론, 자바스크립트
=> 어떻게든 최적화를 해볼테니, 개발자가 추가적인 정보를 줬으면 좋겠다.
이에 대한 대표적인 예가 상수와 변수! 변수는 변해야 하기 때문에 상수에 비해 내부적으로 부가적인 처리가 들어감

## lvalue와 rvalue
let a = 10에서
a -> left value -> lvalue -> 넣는 놈("메모리 위치"로서 동작)
10 -> right value -> rvalue -> 꺼내는 놈("값"으로서 동작)
=> 왼쪽엔 반드시 넣는 놈("메모리 위치"로서 동작)이 와야 함

## 입력
문자열 입력 : prompt()
prompt("message" ,"default" ) => 입력값을 리턴, 입력을 무조건 문자열로 받음

불 입력: confirm()
confirm("message") => true, false 리턴

## 자료형 변환
Number() //다른 것 => 숫자
String() //다른 것 => 문자열
Boolean() //다른 것 => 불

NaN은 자료형은 숫자(number)이고 값이 NaN인 것! typeof를 해보면 number로 나옴.
NaN에 사칙연산을 하면 결과도 NaN
ex) Number("안녕하세요") => NaN 리턴

# 문자열 => 숫자
Number("안녕하세요") => NaN

# 숫자 => 문자열
String(123) => "123"

# 불 => 문자열
String(true) => "true"
String(false) => "false"

# 불 => 숫자
Number(true) => 1
Number(false) => 0

# 다른 자료형 => 불
5가지의 경우 => false
(0, NaN, "", null, undefined)
이외의 경우 => true

3장 조건문
# if else
=> 배타적인 조건이라면 else를 넣어 조건 비교를 줄이는 것이 좋음.

# javascript의 조건에 따른 실행
if 조건문
switch 조건문
조건부 연산자를 활용한 조건 분기
논리 연산자를 활용한 조건 분기


4장 배열
## 배열
배열: 여러 개의 값을 모아놓은 것. 매열 내부의 값을 '요소(element)'라고 부름

## 기본연산
a.length: 요소 개수 추출
a[인덱스]: 요소 추출

## 기본 메소드
# 배열 뒤에 요소 추가하기: push(요소)
# 배열 중간에 요소 추가하기: splice(인덱스, 0, 요소)    //배열.splice(인덱스, 0, 요소)  2번째 매개변수에 0을 입력하면 아무것도 제거하지 않으. 3qjsWo aoroqustndp cnrkgkrh tlvdms dythfmf dlqfur
# 인덱스로 배열의 요소 제거하기: splice(인덱스, 1)      //배열.splice(인덱스, 제거할 요소의 개수)
# 배열 내부에서 값의 위치 찾기: indexOf(요소)
# 값으로 배열의 요소 제거하기: indexOf() + splice() 활용

예시
const a = [52, 273, '안녕', '하세요.']
a.push(100)	// a = [52, 273, '안녕', '하세요.', 100]   a.push(100) => 최종적으로 현재 배열의 요소 개수 리턴
a.splice(1,0,'추가')	// a = [52, '추가', 273, '안녕', '하세요.', 100]
a.splice(0,1)	// a = ['추가', 273, '안녕', '하세요.', 100]    a.splice(0,1) => 52를 리턴
a.indexOf('안녕')	//a.indexOf('안녕') => 2를 리턴


## 기본 자료형과 복합 자료형
스택: 기본 자료형과 주소 등을 저장하는 메모리 공간.
힙: 복합 자료형을 저장하는 메모리 공간
주소: 저장된 자료의 위치
레퍼런스한다: 스택의 주소가 힙의 자료를 가리키는 것.
레퍼런스 변수: 스택에 저장된 것 중에 주소가 저장된 변수.

비파괴적 처리: 어떠한 처리 후 원본이 변경되지 않음. ex) a+b
파괴적 처리: 어떠한 처리 후 원본이 변경됨. ex) a.push(4)

자바스크립트는 1995년도 경에 만들어졌고 이때 당시에는 메모리 등의 자원이 부족했기 때문에
모든 프로그래밍 언어가 파괴적으로 동작했음. (원본을 변경)
현대에는 오류를 줄이기 위해 원본은 원본대로 두고 복사본을 만들어 동작하는 비파괴적 처리를 많이 함.
2010년 이후의 현대에 개발된 자바스크립트의 메소드들은 비파괴적 처리를 함.

# const b = [1,2] 상수로 선언한 배열에 왜 b.push(3)이 가능할까?
const는 스택에 있는 값을 못 변경하게 하는 것!
배열은 힙에 저장되고 배열의 주소값이 스택에 저장됨.
따라서 주소값 자체를 변경하려는 시도는 오류가 발생. ex) b = [1,2,3,4] //새로운 배열로 아예 변경하려함
그러나 힙에 있는 배열 객체를 변경하는 것은 가능! ex) b.push(3)

[정리]
# 스택과 힙: 저장할 때 사용하는 공간
- 스택(stack): 스택스택 쌓는 공간[잘 쌓는 공간]
=> 기본 자료형은 직접 저장되고 복합 자료형은 그 주소가 저장됨

- 힙(heap): 힙힙 던져서 쌓는 공간[대충 큰 것들을 던져서 쌓은 공간]
=> 복합 자료형의 본체가 저장!

# 파괴적 처리 and 비파괴적 처리
처리 후에
- 원본이 변경됨 => 파괴적 처리
- 원본이 변경되지 않음 => 비파괴적 처리

# const의 제한
const => 스택에 있는 값을 변경할 때 오류!!!
=> 따라서, 힙에 있는 레퍼런스된 복합 자료형을 조작하는 것에는 문제 없음.


## 반복
# 배열 등과 함께 사용하는 녀석
forof
for (const 요소 of 배열) { }

forin
for (const 인덱스 in 배열) { }

Q. 궁금증! 왜 forof, forin에서 const로 변수 선언을 할까?
A. let으로 선언해도 문제 없음!
const를 사용할 수 있는 경우에는 const를 사용하는 것이 좋아서 const를 사용한 것입니다![한 번 반복할 때 블럭의 변수들이 초기화되므로, const를 사용할 수 있는 것입니다]

# 범용적으로 사용되는 녀석
for

# while 반복문
while(불 표현식) {
    문장
}

=> 횟수를 기준으로 반복할 때는 코드를 간결하게 구현할 수 있는 for 반복문을 사용하는 것이 훨씬 편함.
while 반복문은 조건에 큰 비중이 있을 때 사용하는 것이 좋음.
