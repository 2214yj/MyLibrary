2장 성능 분석

** 자료 구조 성능 이야기: 빅오
알고리즘 성능을 분석할 때 사용하는 점근적 표기법.

<빅오 종류>
O(1): 상수 시간. 자료구조에 저장된 데이터 개수와 상관없이 정해진 횟수의 연산 안에 알고리즘이 마무리됨. 가장 좋은 예로 동적 배열의 인덱싱이 있다.

O(log n): 로그 시간. 대표적인 예로 이진 탐색 트리 계열에 속하는 자료구조(이진 탐색 트리, 균형 이진 트리, B 트리)의 삽입과 탐색, 삭제 모두 로그 시간이다.

O(n): 선형 시간. 데이터가 늘어날수록 선형으로 연산 횟수가 늘어난다. 대표적으로는 연결리스트의 탐색 연산과 동적 배열에서 배열 마지막에 원소를 추가하는 연산을 제외한 삽입/삭제 연산이 선형 시간이다.

O(nlog n): 선형 로그 시간. 대표적인 예로는 비교 정렬 중에서 가장 성능이 좋다고 알려진 퀵 정렬과 병합 정렬 등이 있다.

O(n^2), O(n^3): O(n^2)는 이중 for 문을 실행할 때, O(n^3)은 삼중 for문을 실행할 때 성능입니다.

O(2^n): 지수 시간입니다. O(n^2)나 O(n^3)에 비해 성능이 훨씬 더 좋지 않다.

* 빅오의 함정
빅오는 연산 횟수를 기반으로 한 상대적인 기준이기 때문에 하드웨어나 다른 외부적인 요소를 전혀 고려하지 않고 있다.

* 추상 데이터 타입이이란
데이터 타입: 데이터를 저장하는 객체(object)와 객체가 할 수 있는 연산(operation)의 집합
객체(object): 데이터 타입이 나타낼 수 있는 모든 값의 집합
추상 데이터 타입(Abstract Data Type): 객체와 연산의 명세에서 객체 표현이나 연산 구현을 감춘 것을 의미한다.
파이썬은 하이 레벨 언어에서도 추상화가 더 많이 되어 있다. (예를 들어, 파이썬은 기본적으로 정수를 int형에 저장한다. 그러다가 최댓값 혹은 최솟값을 넘는 연산이 발생하면 내부적으로 long long으로 변환하여 정수 오버플로가 발생하지 않는다.)
객체에서 표현(어떤 객체를 내부적으로 어떻게 저장할지 고민하는 것)이 감추어졌기 때문에 사용자인 프로그래머는 내부 구현과 상관없이 명세만 보고도 이 함수를 잘 사용할 수 있다.


