5장 리스트, 딕셔너리

리스트와 딕셔너리는 파이썬 코딩테스트에서 빈번하게 사용되는 자료형이다.

** 리스트
리스트는 순서대로 저장하는 시퀀스이자 변경 가능한 목록을 말한다.
입력 순서가 유지되며, 내부적으로는 동적 배열로 구현되어 있다. 파이썬의 리스트는 다양한 자료형을 단일 리스트에 관리할 수 있다.
파이썬 리스트의 가장 좋은 점은 매우 다양한 기능을 제공한다는 점이다. 스택과 큐에서 사용 가능한 모든 연산을 함께 제공한다.
그러나 큐 연산이자 요소를 삭제하는 연산인 pop(0)은 O(n)으로 리스트에서 큐의 연산을 사용할 떄는 주의가 필요하다.
이 경우, 데크(Deque) 같은 자료형으로 성능을 높일 수 있다.

<리스트의 주요 연산 시간 복잡도>
    (연산)         (시간 복잡도)        (설명)
    len(a)          O(1)            전체 요소의 개수를 리턴한다.
    a[i]            O(1)            인덱스 i의 요소를 가져온다.
    a[i:j]          O(k)            인덱스 i부터 j-1까지 슬라이스의 길이만큼인 k개의 요소를 가져온다.
                                    이 경우 객체 k개에 대한 조회가 필요하므로 O(k)이다.

    elem in a       O(n)            elem 요소가 존재하는지 확인한다. 처음부터 순차 탐색하므로 n만큼 시간이 소요된다.
    a.count(elem)   O(n)            elem 요소의 개수를 리턴한다.
    a.index(elem)   O(n)            elem 요소의 인덱스를 리턴한다.
    a.append(elem)  O(1)            리스트 마지막에 elem 요소를 추가한다.
    a.pop()         O(1)            리스트 마지막 요소를 추출한다. 스택의 연산이다.
    a.pop(0)        O(n)            리스트 첫번째 요소를 추출한다. 큐의 연산이다.
                                    이 경우 전체 복사가 필요하므로 O(n)이다. 큐의 연산을 주로 사용한다면 리스트보다는 O(1)에 가능한 데크(deque)를 권장한다.

    del a[i]        O(n)            i에 따라 다르다. 최악의 경우 O(n)이다.
    a.sort()        O(n log n)      정렬한다. Timsort를 사용하며, 최선의 경우 O(n)에도 실행될 수 있다.
    min(a), max(a)  O(n)            최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다.
    a.reverse()     O(n)            뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다.

* 리스트의 특징
파이썬의 리스트는 연속된 공간에 요소를 배치하는 배열의 장점과 다양한 타입을 연결해 배치하는 연결 리스트의 장점을 모두 취한 듯한 형태를 띠며, 실제로 리스트를 잘 사용하기만 해도 배열과 연결 리스트가 모두 필요 없을 정도로 강력하다.
CPython에서 리스트는 요소에 대한 포인터 목록을 갖고 있는 구조체로 선언되어 있다. 리스트에 요소를 추가하거나 조작하기 시작하면 ob_item의 사이즈를 조절해 나가는 형태로 구현되어 있다. 리스트는 이처럼 객체로 되어 있는 모든 자료형을 다음과 같이 포인터로 연결한다.
파이썬의 리스트는 연결 리스트에 대한 포인터 목록을 관리하고 있기 때문에 다양한 타입을 동시에 단일 리스트에서 관리하는 게 가능하다.
그러나 각 자료형의 크기는 저마다 서로 다르기 때문에 이들을 연속된 메모리 공간에 할당하는 것은 불가능하다. 결국 각각의 객체에 대한 참조로 구현할 수밖에 없다.
이에 따라, 값을 조회하기 위해 모든 포인터의 위치를 찾아가서 타입 코드를 화깅ㄴ하고 값을 일일이 살펴봐야 하는 등 추가적인 작업이 필요하기 때문에 속도 면에서도 훨씬 더 불리하다.
이처럼 파이썬은 강력한 기능을 위해 리스트와 객체에 대한 참조를 택했으며 이로 인해 부득이하게 속도를 희생한 측면이 있다.






